// Коннектор: удобный HTTP-клиент для 1С:Предприятие 8
//
// Copyright 2017-2021 Vladimir Bondarevskiy
//
//   Licensed under the Apache License, Version 2.0 (the "License");
//   you may not use this file except in compliance with the License.
//   You may obtain a copy of the License at
//
//       http://www.apache.org/licenses/LICENSE-2.0
//
//   Unless required by applicable law or agreed to in writing, software
//   distributed under the License is distributed on an "AS IS" BASIS,
//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//   See the License for the specific language governing permissions and
//   limitations under the License.
//
//
// URL:    https://github.com/vbondarevsky/Connector
// e-mail: vbondarevsky@gmail.com
// Версия: 2.4.4
//
// Требования: платформа 1С версии 8.3.10 и выше

#Region ПрограммныйИнтерфейс

#Region МетодыHTTP

#Region МетодыОбщегоНазначения

// Отправляет GET запрос
//
// Parameters:
//   URL - String - URL ресурса, к которому будет отправлен запрос.
//   ПараметрыЗапроса - Structure, Map - параметры, которые будут отправлены в URL (часть после ?):
//     * Ключ - String - ключ параметра в URL.
//     * Значение - String - значение параметра URL
//                  - Array - сформирует строку из нескольких параметров: key=value1&key=value2 и т.д.
//   ДополнительныеПараметры - See НовыеПараметры
//   Сессия - See СоздатьСессию
//
// Returns:
//   See ВызватьМетод
//
Function Get(URL, ПараметрыЗапроса = Undefined, ДополнительныеПараметры = Undefined, Сессия = Undefined) Export

	ТекущаяСессия = ТекущаяСессия(Сессия);
	
	Параметры = НовыеПараметры();
	Дополнить(Параметры, ПараметрыИзАргументов(ПараметрыЗапроса, Undefined, Undefined));
	Дополнить(Параметры, ДополнительныеПараметры);
	
	Return ВызватьHTTPМетод(ТекущаяСессия, "GET", URL, Параметры);

EndFunction

// Отправляет OPTIONS запрос
//
// Parameters:
//   URL - String - URL ресурса, к которому будет отправлен запрос.
//   ДополнительныеПараметры - See НовыеПараметры
//   Сессия - See СоздатьСессию
//
// Returns:
//   See ВызватьМетод
//
Function Options(URL, ДополнительныеПараметры = Undefined, Сессия = Undefined) Export

	ТекущаяСессия = ТекущаяСессия(Сессия);
	
	Параметры = НовыеПараметры();
	Дополнить(Параметры, ПараметрыИзАргументов(Undefined, Undefined, Undefined));
	Дополнить(Параметры, ДополнительныеПараметры);
	
	Return ВызватьHTTPМетод(ТекущаяСессия, "OPTIONS", URL, Параметры);

EndFunction

// Отправляет HEAD запрос
//
// Parameters:
//   URL - String - URL ресурса, к которому будет отправлен запрос.
//   ДополнительныеПараметры - See НовыеПараметры
//   Сессия - See СоздатьСессию
//
// Returns:
//   See ВызватьМетод
//
Function Head(URL, ДополнительныеПараметры = Undefined, Сессия = Undefined) Export

	ТекущаяСессия = ТекущаяСессия(Сессия);
	
	Параметры = НовыеПараметры();
	Дополнить(Параметры, ПараметрыИзАргументов(Undefined, Undefined, Undefined));
	Дополнить(Параметры, ДополнительныеПараметры);
	
	Return ВызватьHTTPМетод(ТекущаяСессия, "HEAD", URL, Параметры);

EndFunction

// Отправляет POST запрос
//
// Parameters:
//   URL - String - URL ресурса, к которому будет отправлен запрос.
//   Данные - Structure, Map, String, BinaryData - см. описание ДополнительныеПараметры.Данные.
//   ДополнительныеПараметры - See НовыеПараметры
//   Сессия - See СоздатьСессию
//
// Returns:
//   See ВызватьМетод
//
Function Post(URL, Данные = Undefined, ДополнительныеПараметры = Undefined, Сессия = Undefined) Export

	ТекущаяСессия = ТекущаяСессия(Сессия);
	
	Параметры = НовыеПараметры();
	Дополнить(Параметры, ПараметрыИзАргументов(Undefined, Данные, Undefined));
	Дополнить(Параметры, ДополнительныеПараметры);
	
	Return ВызватьHTTPМетод(ТекущаяСессия, "POST", URL, Параметры);

EndFunction

// Отправляет PUT запрос
//
// Parameters:
//   URL - String - URL ресурса, к которому будет отправлен запрос.
//   Данные - Structure, Map, String, BinaryData - см. описание ДополнительныеПараметры.Данные.
//   ДополнительныеПараметры - See НовыеПараметры
//   Сессия - See СоздатьСессию
//
// Returns:
//   See ВызватьМетод
//
Function Put(URL, Данные = Undefined, ДополнительныеПараметры = Undefined, Сессия = Undefined) Export

	ТекущаяСессия = ТекущаяСессия(Сессия);
	
	Параметры = НовыеПараметры();
	Дополнить(Параметры, ПараметрыИзАргументов(Undefined, Данные, Undefined));
	Дополнить(Параметры, ДополнительныеПараметры);
	
	Return ВызватьHTTPМетод(ТекущаяСессия, "PUT", URL, Параметры);

EndFunction

// Отправляет PATCH запрос
//
// Parameters:
//   URL - String - URL ресурса, к которому будет отправлен запрос.
//   Данные - Structure, Map, String, BinaryData - см. описание ДополнительныеПараметры.Данные.
//   ДополнительныеПараметры - See НовыеПараметры
//   Сессия - See СоздатьСессию
//
// Returns:
//   See ВызватьМетод
//
Function Patch(URL, Данные = Undefined, ДополнительныеПараметры = Undefined, Сессия = Undefined) Export

	ТекущаяСессия = ТекущаяСессия(Сессия);
	
	Параметры = НовыеПараметры();
	Дополнить(Параметры, ПараметрыИзАргументов(Undefined, Данные, Undefined));
	Дополнить(Параметры, ДополнительныеПараметры);
	
	Return ВызватьHTTPМетод(ТекущаяСессия, "PATCH", URL, Параметры);

EndFunction

// Отправляет DELETE запрос
//
// Parameters:
//   URL - String - URL ресурса, к которому будет отправлен запрос.
//   Данные - Structure, Map, String, BinaryData - см. описание ДополнительныеПараметры.Данные.
//   ДополнительныеПараметры - See НовыеПараметры
//   Сессия - See СоздатьСессию
//
// Returns:
//   See ВызватьМетод
//
Function Delete(URL, Данные = Undefined, ДополнительныеПараметры = Undefined, Сессия = Undefined) Export

	ТекущаяСессия = ТекущаяСессия(Сессия);
	
	Параметры = НовыеПараметры();
	Дополнить(Параметры, ПараметрыИзАргументов(Undefined, Данные, Undefined));
	Дополнить(Параметры, ДополнительныеПараметры);
	
	Return ВызватьHTTPМетод(ТекущаяСессия, "DELETE", URL, Параметры);

EndFunction

// Отправляет данные на указанный адрес для обработки с использованием указанного HTTP-метода.
//
// Parameters:
//   Метод - String - имя HTTP-метода для запроса.
//   URL - String - URL ресурса, к которому будет отправлен запрос.
//   ДополнительныеПараметры - See НовыеПараметры
//   Сессия - See СоздатьСессию
//
// Returns:
//   Structure - ответ на выполненный запрос:
//     * ВремяВыполнения - Number - время выполнения запроса в миллисекундах.
//     * Cookies - Map - cookies полученные с сервера.
//     * Headers - Map - HTTP заголовки ответа.
//     * ЭтоПостоянныйРедирект - Boolean - признак постоянного редиректа.
//     * ЭтоРедирект - Boolean - признак редиректа.
//     * Encoding - String - кодировка текста ответа.
//     * Body - BinaryData - тело ответа.
//     * StatusCode - Number - код состояния ответа.
//     * URL - String - итоговый URL, по которому был выполнен запрос.
//
Function ВызватьМетод(Метод, URL, ДополнительныеПараметры = Undefined, Сессия = Undefined) Export

	ТекущаяСессия = ТекущаяСессия(Сессия);
	
	Параметры = НовыеПараметры();
	Дополнить(Параметры, ПараметрыИзАргументов(Undefined, Undefined, Undefined));
	Дополнить(Параметры, ДополнительныеПараметры);
	
	Return ВызватьHTTPМетод(ТекущаяСессия, Метод, URL, Параметры);

EndFunction

#EndRegion

#Region УпрощенныеМетодыДляРаботыСЗапросамиВФорматеJSON

// Отправляет GET запрос
//
// Parameters:
//   URL - String - URL ресурса, к которому будет отправлен запрос.
//   ПараметрыЗапроса - Structure, Map - параметры, которые будут отправлены в URL (часть после ?).
//     См. описание Сессия.ПараметрыЗапроса.
//   ДополнительныеПараметры - See НовыеПараметры
//   Сессия - See СоздатьСессию
//
// Returns:
//   Map, Structure - ответ, десериализованный из JSON.
//     Параметры преобразования см. ДополнительныеПараметры.ПараметрыПреобразованияJSON.
//
Function GetJson(URL,
				ПараметрыЗапроса = Undefined,
				ДополнительныеПараметры = Undefined,
				Сессия = Undefined) Export

	ТекущаяСессия = ТекущаяСессия(Сессия);
	
	Параметры = НовыеПараметры();
	Дополнить(Параметры, ПараметрыИзАргументов(ПараметрыЗапроса, Undefined, Undefined));
	Дополнить(Параметры, ДополнительныеПараметры);
	
	ПараметрыПреобразованияJSON =
		ВыбратьЗначение(Undefined, Параметры, "ПараметрыПреобразованияJSON", Undefined);
	
	Return КакJson(ВызватьHTTPМетод(ТекущаяСессия, "GET", URL, Параметры), ПараметрыПреобразованияJSON);

EndFunction

// Отправляет POST запрос
//
// Parameters:
//   URL - String - URL ресурса, к которому будет отправлен запрос.
//   Json - Structure, Map - данные, которые необходимо сериализовать в JSON.
//   ДополнительныеПараметры - See НовыеПараметры
//   Сессия - See СоздатьСессию
//
// Returns:
//   Map, Structure - ответ, десериализованный из JSON.
//     Параметры преобразования см. ДополнительныеПараметры.ПараметрыПреобразованияJSON
//
Function PostJson(URL, Json, ДополнительныеПараметры = Undefined, Сессия = Undefined) Export

	ТекущаяСессия = ТекущаяСессия(Сессия);
	
	Параметры = НовыеПараметры();
	Дополнить(Параметры, ПараметрыИзАргументов(Undefined, Undefined, Json));
	Дополнить(Параметры, ДополнительныеПараметры);
	
	ПараметрыПреобразованияJSON =
		ВыбратьЗначение(Undefined, Параметры, "ПараметрыПреобразованияJSON", Undefined);
	
	Return КакJson(ВызватьHTTPМетод(ТекущаяСессия, "POST", URL, Параметры), ПараметрыПреобразованияJSON);

EndFunction

// Отправляет PUT запрос
//
// Parameters:
//   URL - String - URL ресурса, к которому будет отправлен запрос.
//   Json - Structure, Map - данные, которые необходимо сериализовать в JSON.
//   ДополнительныеПараметры - See НовыеПараметры
//   Сессия - See СоздатьСессию
//
// Returns:
//   Map, Structure - ответ, десериализованный из JSON.
//     Параметры преобразования см. ДополнительныеПараметры.ПараметрыПреобразованияJSON
//
Function PutJson(URL, Json, ДополнительныеПараметры = Undefined, Сессия = Undefined) Export

	ТекущаяСессия = ТекущаяСессия(Сессия);
	
	Параметры = НовыеПараметры();
	Дополнить(Параметры, ПараметрыИзАргументов(Undefined, Undefined, Json));
	Дополнить(Параметры, ДополнительныеПараметры);
	
	ПараметрыПреобразованияJSON =
		ВыбратьЗначение(Undefined, Параметры, "ПараметрыПреобразованияJSON", Undefined);
	Return КакJson(ВызватьHTTPМетод(ТекущаяСессия, "PUT", URL, Параметры), ПараметрыПреобразованияJSON);

EndFunction

// Отправляет DELETE запрос
//
// Parameters:
//   URL - String - URL ресурса, к которому будет отправлен запрос.
//   Json - Structure, Map - данные, которые необходимо сериализовать в JSON.
//   ДополнительныеПараметры - See НовыеПараметры
//   Сессия - See СоздатьСессию
//
// Returns:
//   Map, Structure - ответ, десериализованный из JSON.
//     Параметры преобразования см. ДополнительныеПараметры.ПараметрыПреобразованияJSON
//
Function DeleteJson(URL, Json, ДополнительныеПараметры = Undefined, Сессия = Undefined) Export

	ТекущаяСессия = ТекущаяСессия(Сессия);
	
	Параметры = НовыеПараметры();
	Дополнить(Параметры, ПараметрыИзАргументов(Undefined, Undefined, Json));
	Дополнить(Параметры, ДополнительныеПараметры);
	
	ПараметрыПреобразованияJSON =
		ВыбратьЗначение(Undefined, Параметры, "ПараметрыПреобразованияJSON", Undefined);
	Return КакJson(ВызватьHTTPМетод(ТекущаяСессия, "DELETE", URL, Параметры), ПараметрыПреобразованияJSON);

EndFunction

#EndRegion

#Region Конструкторы

// Конструктор дополнительных параметров
//
// Возвращаемое значение:
//  Структура - позволяет задать дополнительные параметры:
//    * Заголовки - Соответствие - см. описание Сессия.Заголовки.
//    * Аутентификация - Структура - см. описание Сессия.Аутентификация
//    * Прокси - ИнтернетПрокси - см. описание Сессия.Прокси.
//    * ПараметрыЗапроса - Структура, Соответствие - см. описание Сессия.ПараметрыЗапроса.
//    * ПроверятьSSL - Булево - см. описание Сессия.ПроверятьSSL.
//    * КлиентскийСертификатSSL - СертификатКлиентаФайл, СертификатКлиентаWindows - Значение по умолчанию: Неопределено.
//    * Cookies - Массив - см. описание Сессия.Cookies.
//    * Таймаут - Число - время ожидания осуществляемого соединения и операций, в секундах.
//        Значение по умолчанию - 30 сек.
//    * РазрешитьПеренаправление - Булево - Истина - редиректы будут автоматически разрешены.
//                                          Ложь - будет выполнен только один запрос к серверу.
//    * Json - Структура, Соответствие - данные, которые необходимо сериализовать в JSON.
//    * ПараметрыПреобразованияJSON - Структура - задает параметры преобразования JSON:
//        ** ПрочитатьВСоответствие - Булево - Если Истина, чтение объекта JSON будет выполнено в Соответствие.
//             Если Ложь, объекты будут считываться в объект типа Структура.
//        ** ФорматДатыJSON - ФорматДатыJSON - формат, в котором представлена дата в строке,
//             подлежащей преобразованию.
//        ** ИменаСвойствСоЗначениямиДата -  Строка, Массив Из Строка - имена свойств JSON,
//             для которых нужно вызывать восстановление даты из строки.
//        ** ИмяФункцииВосстановления - Строка - определяет имя функции, которая будет вызывается при чтении
//            каждого свойства и должна иметь следующие параметры:
//               ** Свойство - Строка - указывается только при чтении объектов JSON
//               ** Значение - Произвольный - значение допустимого для сериализации типа
//               ** ДополнительныеПараметры - Произвольный
//            Returns:
//               Arbitrary - значение, десериализованное из JSON. 
//        ** МодульФункцииВосстановления - Произвольный - определяет модуль, процедура которого будет использована для
//            восстановления значения.
//        ** ДополнительныеПараметрыФункцииВосстановления - Произвольный - определяет дополнительные параметры, которые
//            будут переданы в функцию восстановления значений.
//        ** ИменаСвойствДляОбработкиВосстановления - Массив - определяет массив имен свойств JSON, для которых
//            будет вызвана функция восстановления.
//        ** МаксимальнаяВложенность - Число - определяет максимальный уровень вложенности объекта JSON.
//    * ПараметрыЗаписиJSON - ПараметрыЗаписиJSON - используемые при записи объекта JSON.
//    * Данные - Строка, ДвоичныеДанные - произвольные данные, которые необходимо отправить в запросе. 
//             - Структура, Соответствие - поля формы, которые необходимо отправить в запрос:
//                 ** Ключ - Строка - имя поля.
//                 ** Значение - Строка - значение поля.
//    * Файлы - См. НовыйОтправляемыйФайл, Массив Из See НовыйОтправляемыйФайл - файлы, к отправке
//    * МаксимальноеКоличествоПовторов - Число - количество повторных попыток соединения/отправки запроса.
//        Между попытками выполняется задержка, растущая по экспоненте.
//        Но если код состояния один из 413, 429, 503
//        и в ответе есть заголовок Retry-After,
//        то время задержки формируется из значения этого заголовка
//        Значение по умолчанию: 0 - повторы не выполняются.
//    * МаксимальноеВремяПовторов - Число - максимальное общее время (в секундах) отправки запроса с учетом повторов.
//        Значение по умолчанию: 600.
//    * КоэффициентЭкспоненциальнойЗадержки - Число - коэффициент изменения экспоненциальной задержки.
//        1 формирует последовательность задержек: 1, 2, 4, 8 и т.д.
//        2 формируется последовательность задержек: 2, 4, 8, 16 и т.д.
//        ...
//        Значение по умолчанию: 1.
//    * ПовторятьДляКодовСостояний - Неопределено - повторы будут выполняться для кодов состояний >= 500.
//                                 - Массив - повторы будут выполняться для конкретных кодов состояний.
//        Значение по умолчанию: Неопределено.
//
Function НовыеПараметры() Export

	Параметры = New Structure;
	Параметры.Insert("Headers", New Map);
	Параметры.Insert("Аутентификация", Undefined);
	Параметры.Insert("Proxy", Undefined);
	Параметры.Insert("QueryOptions", Undefined);
	Параметры.Insert("ПроверятьSSL", True);
	Параметры.Insert("КлиентскийСертификатSSL", Undefined);
	Параметры.Insert("Cookies", New Map);
	Параметры.Insert("Timeout", СтандартныйТаймаут());
	Параметры.Insert("РазрешитьПеренаправление", True);
	Параметры.Insert("Json", Undefined);
	Параметры.Insert("ПараметрыПреобразованияJSON", ПараметрыПреобразованияJSONПоУмолчанию());
	Параметры.Insert("Data", Undefined);
	Параметры.Insert("Файлы", New Array);
	Параметры.Insert("МаксимальноеКоличествоПовторов", 0);
	Параметры.Insert("МаксимальноеВремяПовторов", 600);
	Параметры.Insert("КоэффициентЭкспоненциальнойЗадержки", 1);
	Параметры.Insert("ПовторятьДляКодовСостояний", Undefined);
	
	Return Параметры;

EndFunction

// Конструктор описания отправляемого файла.
//
// Parameters:
//   Имя - String - имя поля формы.
//   ИмяФайла - String - имя файла.
//   Данные - BinaryData - двоичные данные файла.
//   Тип - String - MIME-тип файла
//
// Returns:
//  Structure:
//    * Name - String - имя поля формы.
//    * FileName - String - имя файла.
//    * Data - BinaryData - двоичные данные файла.
//    * Type - String - MIME-тип файла.
//    * Headers - Map - HTTP заголовки запроса.
//
Function НовыйОтправляемыйФайл(Имя, ИмяФайла, Данные = Undefined, Тип = Undefined) Export
	
	Файл = New Structure;
	Файл.Insert("Name", Имя);
	Файл.Insert("FileName", ИмяФайла);
	Файл.Insert("Data", ?(Данные = Undefined, Base64Value(""), Данные));
	Файл.Insert("Type", Тип);
	Файл.Insert("Headers", New Map);
	
	Return Файл;
	
EndFunction

// Создает объект для хранения параметров сессии.
//
// Returns:
//  Structure - параметры сессии:
//    * Headers - Map - HTTP заголовки запроса.
//    * Аутентификация - Structure - параметры аутентификации запроса.
//          ** ИспользоватьАутентификациюОС - Булево - включает использование аутентификации NTLM или Negotiate.
//                                                   Значение по умолчанию: Ложь.
//          ** Тип - Строка - тип аутентификации. Для Basic Тип можно не указывать.
//       Если Тип = Digest или Basic:
//          ** Пользователь - Строка - имя пользователя.
//          ** Пароль - Строка - пароль пользователя.
//       Если Тип = AWS4-HMAC-SHA256:
//          ** ИдентификаторКлючаДоступа - Строка - идентификатор ключа доступа.
//          ** СекретныйКлюч - Строка - секретный ключ.
//          ** Сервис - Строка - сервис, к которому выполняется подключение.
//          ** Регион - Строка - регион, к которому выполняется подключение.
//    * Proxy - InternetProxy - параметры прокси, которые будут использованы при отправке запроса.
//        Значение по умолчанию: Неопределено. При этом если в конфигурации используется БСП,
//        то значения прокси будет взято из БСП.
//    * QueryOptions - Structure, Map - параметры, которые будут отправлены в URL (часть после ?):
//        * Ключ - String - ключ параметра в URL.
//        * Значение - String - значение параметра URL
//                     - Array - сформирует строку из нескольких параметров: key=value1&key=value2 и т.д.
//    * ПроверятьSSL - Boolean - Ложь - проверка сертификата сервера не выполняется.
//                            - Истина - используется значение СертификатыУдостоверяющихЦентровОС.
//                   - FileCertificationAuthorityCertificates - См. СертификатыУдостоверяющихЦентровФайл.
//        Значение по умолчанию: Истина.
//    * КлиентскийСертификатSSL - FileClientCertificate, WindowsClientCertificate - Значение по умолчанию: Неопределено.
//    * МаксимальноеКоличествоПеренаправлений - Number - максимальное количество редиректов. Защита от зацикливания.
//        Значение по умолчанию: 30
//    * Cookies - Map - хранилище cookies.
//
Function СоздатьСессию() Export

	Сессия = New Structure;
	Сессия.Insert("Headers", ЗаголовкиПоУмолчанию());
	Сессия.Insert("Аутентификация", Undefined);
	Сессия.Insert("Proxy", Undefined);
	Сессия.Insert("QueryOptions", New Structure);
	Сессия.Insert("ПроверятьSSL", True);
	Сессия.Insert("КлиентскийСертификатSSL", Undefined);
	Сессия.Insert("МаксимальноеКоличествоПеренаправлений", МаксимальноеКоличествоПеренаправлений());
	Сессия.Insert("Cookies", New Map);
	Сессия.Insert("СлужебныеДанные", New Structure("ПараметрыDigest"));

	Return Сессия;

EndFunction

// Пакет ответа результата вызова метода HTTP.
//
// Returns:
//   * Метод - Строка - имя HTTP-метода запроса
//   * URL - Строка - итоговый URL, по которому был выполнен запрос.
//   * КодСостояния - Число - Код состояния ответа..
//   * Заголовки - Соответствие - Заголовки ответа.
//   * Тело - ДвоичныеДанные - Тело ответа.
//   * Кодировка - Строка - код кодировки ответа.
//   * ВремяВыполнения - Число - время выполнения запроса в миллисекундах.
//   * ЭтоПостоянныйРедирект - Булево - указывает что это постоянный редирект.
//   * ЭтоРедирект - Булево - указывает что это редирект.
//   * Cookies - Соответствие - хранилище cookies.
//   * Ошибки - Массив Из Строка - Список ошибок возникших в ходе выполнения запроса.
//
Function НовыйОтвет() Export
	
	Результат = New Structure;
	Результат.Insert("Method", "GET");
	Результат.Insert("URL", "");
	Результат.Insert("StatusCode", 600); // Сетевая ошибка (>500)
	Результат.Insert("Headers", New Map);
	Результат.Insert("Body", Base64Value(""));
	Результат.Insert("Encoding", "utf-8");
	Результат.Insert("ВремяВыполнения", Undefined);
	Результат.Insert("ЭтоПостоянныйРедирект", False);
	Результат.Insert("ЭтоРедирект", False);
	Результат.Insert("Cookies", New Map);
	Результат.Insert("Ошибки", New Array);
	
	Return Результат;
	
EndFunction

#EndRegion

#EndRegion

#Region ФорматыОтветов

// Возвращает ответ сервера в виде десериализованного значения JSON.
//
// Parameters:
//   Ответ - See НовыйОтвет
//   ПараметрыПреобразованияJSON - Structure - задает параметры преобразования JSON.
//     * ПрочитатьВСоответствие - Булево - Если Истина, чтение объекта JSON будет выполнено в Соответствие.
//                                         Если Ложь, объекты будут считываться в объект типа Структура.
//     * ФорматДатыJSON - ФорматДатыJSON - формат, в котором представлена дата в строке, подлежащей преобразованию.
//     * ИменаСвойствСоЗначениямиДата -  Массив, Строка - имена свойств JSON,
//         для которых нужно вызывать восстановление даты из строки.
//     * ИмяФункцииВосстановления - Строка - определяет имя функции, которая будет вызывается при чтении
//         каждого свойства и должна иметь следующие параметры:
//            ** Свойство - Строка - указывается только при чтении объектов JSON
//            ** Значение - Произвольный - значение допустимого для сериализации типа
//            ** ДополнительныеПараметры - Произвольный
//         Возвращаемое значение:
//            Произвольный - значение, десериализованное из JSON. 
//     * МодульФункцииВосстановления - Произвольный - определяет модуль, процедура которого будет использована для
//         восстановления значения.
//     * ДополнительныеПараметрыФункцииВосстановления - Произвольный - определяет дополнительные параметры, которые
//         будут переданы в функцию восстановления значений.
//     * ИменаСвойствДляОбработкиВосстановления - Массив - определяет массив имен свойств JSON, для которых
//         будет вызвана функция восстановления.
//     * МаксимальнаяВложенность - Число - определяет максимальный уровень вложенности объекта JSON.
//
// Returns:
//   Map - ответ сервера в виде десериализованного значения JSON.
//     Если ПараметрыПреобразования.ПрочитатьВСоответствие = Истина (по умолчанию).
//   Структура - если ПараметрыПреобразования.ПрочитатьВСоответствие = Ложь.
//
Function КакJson(Ответ, ПараметрыПреобразованияJSON = Undefined) Export
		
	Try
		Return JsonВОбъект(РаспаковатьОтвет(Ответ), Ответ.Encoding, ПараметрыПреобразованияJSON);
	Except
		Raise КакИсключение(Ответ, NStr("ru = 'Ошибка при десериализации JSON.';
													|en = 'Ошибка при десериализации JSON.';"));
	EndTry;

EndFunction

// Возвращает ответ сервера в виде текста.
//
// Parameters:
//   Ответ - See НовыйОтвет
//   Кодировка - String, TextEncoding - определяет кодировку текста.
//     Если значение не задано, то кодировка извлекается из Ответ.Кодировка.
//
// Returns:
//   String - ответ сервера в виде текста.
//
Function КакТекст(Ответ, Кодировка = Undefined) Export

	If Not ValueIsFilled(Кодировка) Then
		Кодировка = Ответ.Encoding;
	EndIf;

	TextReader = New TextReader(РаспаковатьОтвет(Ответ).OpenStreamForRead(), Кодировка);
	Текст = TextReader.Read();
	TextReader.Close();

	If Текст = Undefined Then
		Текст = "";
	EndIf;

	Return Текст;

EndFunction

// Возвращает ответ сервера в двоичных данных.
//
// Parameters:
//   Ответ - See НовыйОтвет
//
// Returns:
//   String - ответ сервера в виде двоичных данных.
//
Function КакДвоичныеДанные(Ответ) Export

	Return РаспаковатьОтвет(Ответ);

EndFunction

// Возвращает ответ сервера в XDTO.
//
// Parameters:
//   Ответ - See НовыйОтвет
//   ПараметрыЧтенияXML - XMLReaderSettings - Параметры чтения, которые будут использованы при чтении данных XML
//     Подробнее см. в синтакс помощнике метод ЧтениеXML.ОткрытьПоток
//   НаборСхемXML - XMLSchemaSet - Набор схем XML, используемых при проверке читаемого документа XML.
//     Если набор схем указан, но не проверен и включена проверка документа XML,
//     то будет выполнена проверка набора схем
//     Подробнее см. в синтакс помощнике метод ЧтениеXML.ОткрытьПоток
//   Кодировка - String, TextEncoding - Позволяет задать кодировку.
//     Подробнее см. в синтакс помощнике метод ЧтениеXML.ОткрытьПоток
//
// Returns:
//   XDTODataObject, XDTOList - тип возвращаемого значения может быть любым из поддерживаемых сериализацию в XDTO.
//
Function КакXDTO(Ответ,
				ПараметрыЧтенияXML = Undefined,
				НаборСхемXML = Undefined,
				Кодировка = Undefined) Export

	Try
		BinaryData = РаспаковатьОтвет(Ответ);
		
		ПотокДляЧтения = BinaryData.OpenStreamForRead();
	
		If Not ValueIsFilled(Кодировка) Then
			Кодировка = Ответ.Encoding;
		EndIf;
	
		XMLReader = New XMLReader;
		XMLReader.OpenStream(ПотокДляЧтения, ПараметрыЧтенияXML, НаборСхемXML, Кодировка);
	
		ОбъектXDTO = XDTOFactory.ReadXML(XMLReader);
	Except
		Raise КакИсключение(Ответ, NStr("ru = 'Ошибка при десериализации XDTO.';
													|en = 'Ошибка при десериализации XDTO.';"));
	EndTry;

	Return ОбъектXDTO;

EndFunction

// Возвращает ответ сервера в виде текста предназначенного для использования в ВызватьИсключение.
//
// Parameters:
//   Ответ - See НовыйОтвет.
//   ТекстДляПользователя - String - Текст пояснения причины для пользователя.
//
// Returns:
//   String - ответ сервера в виде текста исключения.
//
Function КакИсключение(Ответ, Val ТекстДляПользователя = Undefined) Export
	
	ТекстИсключения = StrTemplate(
		NStr("ru = 'HTTP %1 %2
		           |%3';
					|en = 'HTTP %1 %2
					|%3';"),
		Ответ.Method,
		Ответ.URL,
		ПредставлениеКодаСостоянияHTTP(Ответ.StatusCode)
	);
	
	ТелоОтвета = ВырезатьТекст(КакТекст(Ответ));
	
	If Not IsBlankString(ТелоОтвета) Then
		ТекстИсключения = ТекстИсключения + Chars.LF + StrTemplate(
			NStr("ru = 'Тело ответа:
			           |%1';
						|en = 'Тело ответа:
						|%1';"),
			ТелоОтвета);
	EndIf;
	
	If Ответ.Ошибки.Count() Then
		ТекстИсключения = ТекстИсключения + Chars.LF + Chars.LF
			+ StrConcat(Ответ.Ошибки, Chars.LF + Chars.LF);
	EndIf;
	
	If Not IsBlankString(ТекстДляПользователя) Then
		ТекстИсключения = ТекстДляПользователя + Chars.LF + Chars.LF + ТекстИсключения;
	EndIf;
	
	Return ТекстИсключения;
	
EndFunction

#EndRegion

#Region ВспомогательныеФункции

// Возвращает структурированное представление URL.
//
// Parameters:
//   URL - String - URL ресурса, к которому будет отправлен запрос.
//
// Returns:
//   Structure - структура URL:
//     * Schema - String - схема обращения к серверу (http, https).
//     * Аутентификация - Structure - параметры аутентификации:
//         ** User - String - имя пользователя.
//         ** Password - String - пароль пользователя.
//     * Server - String - адрес сервера.
//     * Port - Number - порт сервера.
//     * Path - String - адрес ресурса на сервере.
//     * QueryOptions - Map - параметры запроса передаваемые на сервер в URL (часть после ?):
//         ** Ключ - String - ключ параметра в URL.
//         ** Значение - String - значение параметра URL;
//                       - Array - значения параметра (key=value1&key=value2).
//     * Particle - String - часть URL после #.
//
Function РазобратьURL(Val URL) Export

	Схема = "";
	Путь = "";
	Аутентификация = New Structure("User, Password", "", "");
	Сервер = "";
	Порт = "";
	Фрагмент = "";

	ДопустимыеСхемы = StrSplit("http,https", ",");

	URLБезСхемы = URL;
	РазбитьСтрокуПоРазделителю(Схема, URLБезСхемы, "://");
	If ДопустимыеСхемы.Find(Lower(Схема)) <> Undefined Then
		URL = URLБезСхемы;
	Else
		Схема = "";
	EndIf;

	Результат = РазделитьПоПервомуНайденномуРазделителю(URL, StrSplit("/,?,#", ","));
	URL = Результат[0];
	If ValueIsFilled(Результат[2]) Then
		Путь = Результат[2] + Результат[1];
	EndIf;

	АутентификацияСтрока = "";
	РазбитьСтрокуПоРазделителю(АутентификацияСтрока, URL, "@");
	If ValueIsFilled(АутентификацияСтрока) Then
		АутентификацияЧасти = StrSplit(АутентификацияСтрока, ":");
		Аутентификация.User = АутентификацияЧасти[0];
		If АутентификацияЧасти.Count() > 1 Then
			Аутентификация.Password = АутентификацияЧасти[1];
		EndIf;
	EndIf;

	// IPv6
	РазбитьСтрокуПоРазделителю(Сервер, URL, "]");
	If ValueIsFilled(Сервер) Then
		Сервер = Сервер + "]";
	EndIf;

	URL = StrReplace(URL, "/", "");

	РазбитьСтрокуПоРазделителю(Порт, URL, ":", True);

	If Not ValueIsFilled(Сервер) Then
		Сервер = URL;
	EndIf;

	If ValueIsFilled(Порт) Then
		Порт = Number(Порт);
	Else
		Порт = 0;
	EndIf;

	РазбитьСтрокуПоРазделителю(Фрагмент, Путь, "#", True);

	ПараметрыЗапроса = ЗаполнитьПараметрыЗапроса(Путь);

	If Not ValueIsFilled(Схема) Then
		Схема = "http";
	EndIf;

	If Not ValueIsFilled(Путь) Then
		Путь = "/";
	EndIf;

	Результат = New Structure;
	Результат.Insert("Schema", Схема);
	Результат.Insert("Аутентификация", Аутентификация);
	Результат.Insert("Server", Сервер);
	Результат.Insert("Port", Порт);
	Результат.Insert("Path", Путь);
	Результат.Insert("QueryOptions", ПараметрыЗапроса);
	Результат.Insert("Particle", Фрагмент);

	Return Результат;

EndFunction

// Преобразование Объекта в JSON.
//
// Parameters:
//   Объект - Arbitrary - данные, которые необходимо преобразовать в JSON.
//   ПараметрыПреобразования - Structure - кодировка текста JSON. Значение по умолчанию - utf-8.
//     * ФорматДатыJSON - ФорматДатыJSON - определяет формат сериализации дат JSON-объектов.
//     * ВариантЗаписиДатыJSON - ВариантЗаписиДатыJSON - определяет вариант записи даты в формате JSON.
//     * ИмяФункцииПреобразования - Строка - функция, которая вызывается для всех свойств,
//         тип которых не поддерживает автоматическую сериализацию в JSON.
//         Функция должна быть экспортируемая и иметь следующие параметры:
//           ** Свойство - Строка - свойство структуры данных, которое не может быть
//                автоматически сериализовано в JSON.
//           ** Значение - Строка - значение свойства структуры данных, которое
//                не может быть автоматически сериализовано в JSON.
//           ** ДополнительныеПараметры - Произвольный - в этом параметре будет передан
//                ДополнительныеПараметрыФункцииПреобразования.
//           ** Отказ - Булево - отменяет операцию записи свойства.
//         Возвращаемое значение функции:
//           Произвольный - результат преобразования.
//     * МодульФункцииПреобразования - Произвольный - модуль, в котором определена функция ИмяФункцииПреобразования.
//     * ДополнительныеПараметрыФункцииПреобразования - Произвольный - параметры, которые будут переданы
//                                                                     в функцию ИмяФункцииПреобразования.
//   ПараметрыЗаписи - Structure - параметры преобразования JSON:
//     * ПереносСтрок - JSONLineBreak - определяет способ переноса строк,
//         который будет использован при записи данных JSON.
//     * СимволыОтступа - String - определяет символы отступа, используемые при записи данных JSON.
//     * ИспользоватьДвойныеКавычки - Boolean - определяет, будут ли при записи имена свойств JSON
//         записываться в двойных кавычках.
//     * ЭкранированиеСимволов - JSONCharactersEscapeMode - определяет используемый способ экранирования (замены)
//         символов при записи данных JSON.
//     * ЭкранироватьУгловыеСкобки - Boolean - определяет, будут ли при записи экранироваться символы "<" и ">".
//     * ЭкранироватьРазделителиСтрок - Boolean - определяет, будут ли экранироваться разделители строк
//         U+2028 (line-separator) и U+2029 (page-separator).
//     * ЭкранироватьАмперсанд - Boolean - определяет, будет ли при записи экранироваться символ амперсанда "&".
//     * ЭкранироватьОдинарныеКавычки - Boolean - определяет, будут ли экранироваться одинарные кавычки.
//     * ЭкранироватьСлеш - Boolean - определяет, будет ли экранироваться слеш (косая черта) при записи значения.
//
// Returns:
//   String - объект в формате JSON.
//
Function ОбъектВJson(Объект, Val ПараметрыПреобразования = Undefined, Val ПараметрыЗаписи = Undefined) Export

	ПараметрыПреобразованияJSON = Объединить(ПараметрыПреобразованияJSONПоУмолчанию(), ПараметрыПреобразования);

	НастройкиСериализации = New JSONSerializerSettings;
	НастройкиСериализации.ФорматСериализацииДаты = ПараметрыПреобразованияJSON.ФорматДатыJSON;
	НастройкиСериализации.DateWritingVariant = ПараметрыПреобразованияJSON.ВариантЗаписиДатыJSON;

	ПараметрыЗаписи = Объединить(ПараметрыЗаписиJSONПоУмолчанию(), ПараметрыЗаписи);

	JSONWriterSettings = New JSONWriterSettings(
		ПараметрыЗаписи.NewLines,
		ПараметрыЗаписи.IndentChars,
		ПараметрыЗаписи.UseDoubleQuotes,
		ПараметрыЗаписи.EscapeCharacters,
		ПараметрыЗаписи.EscapeAngleBrackets,
		ПараметрыЗаписи.EscapeLineTerminators,
		ПараметрыЗаписи.EscapeAmpersand,
		ПараметрыЗаписи.EscapeSingleQuotes,
		ПараметрыЗаписи.EscapeSlash);

	JSONWriter = New JSONWriter;
	JSONWriter.SetString(JSONWriterSettings);

	If ПараметрыПреобразованияJSON.ИмяФункцииПреобразования <> Undefined
		And ПараметрыПреобразованияJSON.МодульФункцииПреобразования <> Undefined Then
		WriteJSON(JSONWriter, Объект, НастройкиСериализации,
			ПараметрыПреобразованияJSON.ИмяФункцииПреобразования,
			ПараметрыПреобразованияJSON.МодульФункцииПреобразования,
			ПараметрыПреобразованияJSON.ДополнительныеПараметрыФункцииПреобразования);
	Else
		WriteJSON(JSONWriter, Объект, НастройкиСериализации);
	EndIf;

	Return JSONWriter.Close();

EndFunction

// Преобразование JSON в Объект.
//
// Parameters:
//   Json - Stream, BinaryData, String - данные в формате JSON.
//   Кодировка - String - кодировка текста JSON. Значение по умолчанию - utf-8.
//   ПараметрыПреобразования - Structure - параметры преобразования JSON:
//     * ПрочитатьВСоответствие - Boolean - если Истина, чтение объекта JSON будет выполнено в Соответствие,
//         иначе в Структура.
//     * ИменаСвойствСоЗначениямиДата - Array, String, FixedArray - имена свойств JSON,
//         для которых нужно вызывать восстановление даты из строки.
//     * ФорматДатыJSON - JSONDateFormat - определяет формат десериализации дат JSON-объектов.
//     * ИмяФункцииВосстановления - String - определяет имя функции, которая будет вызывается при чтении
//         каждого свойства и должна иметь следующие параметры:
//            ** Свойство - String - указывается только при чтении объектов JSON
//            ** Значение - Arbitrary - значение допустимого для сериализации типа
//            ** ДополнительныеПараметры - Arbitrary
//         Возвращаемое значение:
//            Произвольный - значение, десериализованное из JSON. 
//     * МодульФункцииВосстановления - Произвольный - определяет модуль, процедура которого будет использована для
//         восстановления значения.
//     * ДополнительныеПараметрыФункцииВосстановления - Произвольный - определяет дополнительные параметры, которые
//         будут переданы в функцию восстановления значений.
//     * ИменаСвойствДляОбработкиВосстановления - Массив - определяет массив имен свойств JSON, для которых
//         будет вызвана функция восстановления.
//     * МаксимальнаяВложенность - Число - определяет максимальный уровень вложенности объекта JSON.
//
// Returns:
//   Arbitrary - значение, десериализованное из JSON.
//
Function JsonВОбъект(Json, Кодировка = "utf-8", ПараметрыПреобразования = Undefined) Export

	ПараметрыПреобразованияJSON = Объединить(ПараметрыПреобразованияJSONПоУмолчанию(), ПараметрыПреобразования);

	JSONReader = New JSONReader;
	If TypeOf(Json) = Type("BinaryData") Then
		JSONReader.OpenStream(Json.OpenStreamForRead(), Кодировка);
	ElsIf TypeOf(Json) = Type("String") Then
		JSONReader.SetString(Json);
	Else
		JSONReader.OpenStream(Json, Кодировка);
	EndIf;
	Объект = ReadJSON(
		JSONReader,
		ПараметрыПреобразованияJSON.ПрочитатьВСоответствие,
		ПараметрыПреобразованияJSON.ИменаСвойствСоЗначениямиДата,
		ПараметрыПреобразованияJSON.ФорматДатыJSON,
		ПараметрыПреобразованияJSON.ИмяФункцииВосстановления,
		ПараметрыПреобразованияJSON.МодульФункцииВосстановления,
		ПараметрыПреобразованияJSON.ДополнительныеПараметрыФункцииВосстановления,
		ПараметрыПреобразованияJSON.ИменаСвойствДляОбработкиВосстановления,
		ПараметрыПреобразованияJSON.МаксимальнаяВложенность);
	JSONReader.Close();

	Return Объект;

EndFunction

// Вычисляет HMAC (hash-based message authentication code).
//
// Parameters:
//   Ключ - BinaryData - секретный ключ.
//   Данные - BinaryData - данные, для которых нужно посчитать HMAC.
//   Алгоритм - HashFunction - алгоритм, используемый для вычисления хеша.
//
// Returns:
//   BinaryData - вычисленное значение HMAC.
//
Function HMAC(Ключ, Данные, Алгоритм) Export

	ДлинаБлока = 64;

	If Ключ.Size() > ДлинаБлока Then
		Хеширование = New DataHashing(Алгоритм);
		Хеширование.Append(Ключ);

		КлючБуфер = GetBinaryDataBufferFromBinaryData(Хеширование.HashSum);
	Else
		КлючБуфер = GetBinaryDataBufferFromBinaryData(Ключ);
	EndIf;

	ИзмененныйКлюч = New BinaryDataBuffer(ДлинаБлока);
	ИзмененныйКлюч.Write(0, КлючБуфер);

	ВнутреннийКлюч = ИзмененныйКлюч.Copy();
	ВнешнийКлюч = ИзмененныйКлюч;

	ВнутреннееВыравнивание = New BinaryDataBuffer(ДлинаБлока);
	ВнешнееВыравнивание = New BinaryDataBuffer(ДлинаБлока);
	For Индекс = 0 To ДлинаБлока - 1 Do
		ВнутреннееВыравнивание.Set(Индекс, 54);
		ВнешнееВыравнивание.Set(Индекс, 92);
	EndDo;

	ВнутреннееХеширование = New DataHashing(Алгоритм);
	ВнешнееХеширование = New DataHashing(Алгоритм);

	ВнутреннийКлюч.WriteBitwiseXor(0, ВнутреннееВыравнивание);
	ВнешнийКлюч.WriteBitwiseXor(0, ВнешнееВыравнивание);

	ВнешнееХеширование.Append(GetBinaryDataFromBinaryDataBuffer(ВнешнийКлюч));
	ВнутреннееХеширование.Append(GetBinaryDataFromBinaryDataBuffer(ВнутреннийКлюч));

	If ValueIsFilled(Данные) Then
		ВнутреннееХеширование.Append(Данные);
	EndIf;

	ВнешнееХеширование.Append(ВнутреннееХеширование.HashSum);

	Return ВнешнееХеширование.HashSum;

EndFunction

// Возвращает структуру именованных кодов состояний HTTP.
//
// Returns:
//   Structure - именованные коды состояний HTTP.
//
Function КодыСостоянияHTTP() Export

	КодыСостояния = New Structure;
	For Each Описание In ОписанияКодовСостоянийHTTP() Do
		КодыСостояния.Insert(Описание.Key, Описание.Code);
	EndDo;

	Return КодыСостояния;

EndFunction

// Возвращает текстовое представление переданного кода состояния HTTP.
//
// Parameters:
//   КодСостояния - Number - код состояния HTTP, для которого нужно получить текстовое представление.
//
// Returns:
//   String - текстовое представление кода состояния HTTP.
//
Function ПредставлениеКодаСостоянияHTTP(КодСостояния) Export

	ОписаниеКодаСостояния = Undefined;
	For Each Описание In ОписанияКодовСостоянийHTTP() Do
		If Описание.Code = КодСостояния Then
			ОписаниеКодаСостояния = Описание;
			Break;
		EndIf;
	EndDo;

	If ОписаниеКодаСостояния = Undefined Then
		Return StrTemplate(NStr("ru = '%1: Неизвестный код состояния HTTP';
								|en = '%1: Неизвестный код состояния HTTP';"), КодСостояния);
	Else
		Return StrTemplate("%1: %2", ОписаниеКодаСостояния.Code, ОписаниеКодаСостояния.Description);
	EndIf;

EndFunction

// Выполняет чтение данных из архива GZip.
//
// Parameters:
//   СжатыеДанные - BinaryData - данные упакованные GZip.
//
// Returns:
//   BinaryData - распакованные данные.
//
Function ПрочитатьGZip(СжатыеДанные) Export

	РазмерПрефиксаGZip = 10;
	РазмерПостфиксаGZip = 8;

	DataReader = New DataReader(СжатыеДанные);
	DataReader.Skip(РазмерПрефиксаGZip);
	РазмерСжатыхДанных = DataReader.SourceStream().Size() - РазмерПрефиксаGZip - РазмерПостфиксаGZip;

	ПотокZip = New MemoryStream(ZipРазмерLFH() + РазмерСжатыхДанных + ZipРазмерDD() + ZipРазмерCDH() + ZipРазмерEOCD());
	DataWriter = New DataWriter(ПотокZip);
	DataWriter.WriteBinaryDataBuffer(ZipLFH());
	DataReader.CopyTo(DataWriter, РазмерСжатыхДанных);

	DataWriter.Close();
	DataWriter = New DataWriter(ПотокZip);

	CRC32 = DataReader.ReadInt32();
	РазмерНесжатыхДанных = DataReader.ReadInt32();
	DataReader.Close();

	DataWriter.WriteBinaryDataBuffer(ZipDD(CRC32, РазмерСжатыхДанных, РазмерНесжатыхДанных));
	DataWriter.WriteBinaryDataBuffer(ZipCDH(CRC32, РазмерСжатыхДанных, РазмерНесжатыхДанных));
	DataWriter.WriteBinaryDataBuffer(ZipEOCD(РазмерСжатыхДанных));
	DataWriter.Close();

	Return ПрочитатьZip(ПотокZip);

EndFunction

// Выполняет запись данных в архив GZip.
//
// Parameters:
//   Данные - BinaryData - исходные данные.
//
// Returns:
//   BinaryData - данные упакованные GZip.
//
Function ЗаписатьGZip(Данные) Export

	DataReader = New DataReader(ЗаписатьZip(Данные));

	НачальноеСмещение = 14;
	DataReader.Skip(НачальноеСмещение);
	CRC32 = DataReader.ReadInt32();

	РазмерСжатыхДанных = DataReader.ReadInt32();
	РазмерИсходныхДанных = DataReader.ReadInt32();

	РазмерИмениФайла = DataReader.ReadInt16();
	РазмерДополнительногоПоля = DataReader.ReadInt16();
	DataReader.Skip(РазмерИмениФайла + РазмерДополнительногоПоля);

	ПотокGZip = New MemoryStream;
	DataWriter = New DataWriter(ПотокGZip);
	DataWriter.WriteBinaryDataBuffer(GZipHeader());
	DataReader.CopyTo(DataWriter, РазмерСжатыхДанных);
	DataWriter.Close();
	DataWriter = New DataWriter(ПотокGZip);

	DataWriter.WriteBinaryDataBuffer(GZipFooter(CRC32, РазмерИсходныхДанных));

	Return ПотокGZip.CloseAndGetBinaryData();

EndFunction

#EndRegion

#EndRegion

#Region СлужебныйПрограммныйИнтерфейс

Function ПодготовитьЗапрос(Сессия, Метод, URL, ДополнительныеПараметры) Export

	Cookies = ВыбратьЗначение(Undefined, ДополнительныеПараметры, "Cookies", New Array);
	Cookies = ОбъединитьCookies(ДозаполнитьCookie(Сессия.Cookies, URL), ДозаполнитьCookie(Cookies, URL));

	АутентификацияИзДополнительныхПараметров =
		ВыбратьЗначение(Undefined, ДополнительныеПараметры, "Аутентификация", New Structure);
	ПараметрыЗапросаИзДополнительныхПараметров =
		ВыбратьЗначение(Undefined, ДополнительныеПараметры, "QueryOptions", New Structure);
	ЗаголовкиИзДополнительныхПараметров =
		ВыбратьЗначение(Undefined, ДополнительныеПараметры, "Headers", New Map);

	Аутентификация = Объединить(Скопировать(АутентификацияИзДополнительныхПараметров), Сессия.Аутентификация);
	ПараметрыЗапроса = Объединить(Скопировать(ПараметрыЗапросаИзДополнительныхПараметров), Сессия.QueryOptions);
	Заголовки = Объединить(Скопировать(ЗаголовкиИзДополнительныхПараметров), Сессия.Headers);
	ПараметрыПреобразованияJSON =
		ВыбратьЗначение(Undefined, ДополнительныеПараметры, "ПараметрыПреобразованияJSON", Undefined);

	ПодготовленныйЗапрос = New Structure;
	ПодготовленныйЗапрос.Insert("Cookies", Cookies);
	ПодготовленныйЗапрос.Insert("Аутентификация", Аутентификация);
	ПодготовленныйЗапрос.Insert("Method", Метод);
	ПодготовленныйЗапрос.Insert("Headers", Заголовки);
	ПодготовленныйЗапрос.Insert("QueryOptions", ПараметрыЗапроса);
	ПодготовленныйЗапрос.Insert("URL", ПодготовитьURL(URL, ПараметрыЗапроса));
	ПодготовленныйЗапрос.Insert("ПараметрыПреобразованияJSON", ПараметрыПреобразованияJSON);

	ПодготовитьCookies(ПодготовленныйЗапрос);

	Данные = ВыбратьЗначение(Undefined, ДополнительныеПараметры, "Data", New Structure);
	Файлы = ВыбратьЗначение(Undefined, ДополнительныеПараметры, "Файлы", New Array);
	Json = ВыбратьЗначение(Undefined, ДополнительныеПараметры, "Json", Undefined);
	ПараметрыЗаписиJSON = ВыбратьЗначение(Undefined, ДополнительныеПараметры, "ПараметрыЗаписиJSON", Undefined);

	ПодготовитьТелоЗапроса(ПодготовленныйЗапрос, Данные, Файлы, Json, ПараметрыЗаписиJSON);
	ПодготовитьАутентификацию(ПодготовленныйЗапрос);

	Return ПодготовленныйЗапрос;

EndFunction

#EndRegion

#Region СлужебныеПроцедурыИФункции

#Region РаботаСHTTPЗапросами

Function ПараметрыИзАргументов(ПараметрыЗапроса, Данные, Json)

	Результат = New Structure;
	Результат.Insert("QueryOptions", ПараметрыЗапроса);
	Результат.Insert("Data", Данные);
	Результат.Insert("Json", Json);
	
	Return Результат;

EndFunction

Function ВызватьHTTPМетод(Сессия, Метод, URL, ДополнительныеПараметры)

	ПодготовленныйЗапрос = ПодготовитьЗапрос(Сессия, Метод, URL, ДополнительныеПараметры);

	НастройкиПодключения = НастройкиПодключения(Метод, URL, ДополнительныеПараметры);

	Ответ = ОтправитьЗапрос(Сессия, ПодготовленныйЗапрос, НастройкиПодключения);
	
	If НастройкиПодключения.РазрешитьПеренаправление And Ответ.ЭтоРедирект Then
		// INFO: по хорошему аутентификацию нужно привести к новых параметрам, но пока будем игнорировать.
		Ответ = ПеренаправитьЗапрос(Сессия, НастройкиПодключения, ПодготовленныйЗапрос, Ответ);
	EndIf;
	
	Return Ответ;

EndFunction

Function ПеренаправитьЗапрос(Сессия, НастройкиПодключения, ПодготовленныйЗапрос, ПеренаправленныйОтвет)
	
	Перенаправление = 0;
	
	While ПеренаправленныйОтвет.ЭтоРедирект Do
		
		ПодготовитьЗапросДляРедиректа(Сессия, ПодготовленныйЗапрос, ПеренаправленныйОтвет);
		
		ПеренаправленныйОтвет = ОтправитьЗапрос(Сессия, ПодготовленныйЗапрос, НастройкиПодключения);
		
		Перенаправление = Перенаправление + 1;
		
		If Перенаправление > Сессия.МаксимальноеКоличествоПеренаправлений Then
			Raise("СлишкомМногоПеренаправлений");
		EndIf;
		
	EndDo;
	
	Return ПеренаправленныйОтвет;
	
EndFunction

Procedure ПодготовитьЗапросДляРедиректа(Сессия, ПодготовленныйЗапрос, ПеренаправленныйОтвет)
	
	КодыСостоянияHTTP = КодыСостоянияHTTP();
	
	НовыйURL = СформироватьНовыйURLПриПеренаправлении(ПеренаправленныйОтвет);
	
	ПодготовленныйЗапрос.URL = EncodeString(НовыйURL, StringEncodingMethod.URLInURLEncoding);
	НовыйHTTPЗапрос = New HTTPRequest(СобратьАдресРесурса(РазобратьURL(НовыйURL), Undefined));
	ПереопределитьМетод(ПодготовленныйЗапрос, ПеренаправленныйОтвет);

	If ПеренаправленныйОтвет.StatusCode <> КодыСостоянияHTTP.ВременноеПеренаправление_307
		And ПеренаправленныйОтвет.StatusCode <> КодыСостоянияHTTP.ПостоянноеПеренаправление_308 Then
		УдалитьЗаголовки(ПодготовленныйЗапрос.Headers, "content-length,content-type,transfer-encoding");
		НовыйHTTPЗапрос.Headers = ПодготовленныйЗапрос.Headers;
	Else
		ИсходныйПоток = ПодготовленныйЗапрос.HTTPЗапрос.GetBodyAsStream();
		ИсходныйПоток.CopyTo(НовыйHTTPЗапрос.GetBodyAsStream());
	EndIf;
	
	ПодготовленныйЗапрос.HTTPЗапрос = НовыйHTTPЗапрос;
	УдалитьЗаголовки(ПодготовленныйЗапрос.Headers, "cookies");

	ПодготовленныйЗапрос.Cookies = ОбъединитьCookies(Сессия.Cookies, ПодготовленныйЗапрос.Cookies);
	ПодготовитьCookies(ПодготовленныйЗапрос);
	
EndProcedure

Procedure ПодготовитьАутентификацию(ПодготовленныйЗапрос)

	ПодготовленныйЗапрос.Insert("СобытияНаОтвет", New Array);
	If Not ValueIsFilled(ПодготовленныйЗапрос.Аутентификация) Then
		СтруктураURL = РазобратьURL(ПодготовленныйЗапрос.URL);
		If ValueIsFilled(СтруктураURL.Аутентификация) Then
			ПодготовленныйЗапрос.Аутентификация = СтруктураURL.Аутентификация;
		EndIf;
	EndIf;

	If ValueIsFilled(ПодготовленныйЗапрос.Аутентификация) Then
		If ПодготовленныйЗапрос.Аутентификация.Property("Type") Then
			ТипАутентификации = Lower(ПодготовленныйЗапрос.Аутентификация.Type);
			If ТипАутентификации = "digest" Then
				ПодготовленныйЗапрос.СобытияНаОтвет.Add("ОбработкаОтветаСКодом401");
			EndIf;
			If ТипАутентификации = "aws4-hmac-sha256" Then
				ПодготовитьАутентификациюAWS4(ПодготовленныйЗапрос);
			EndIf;
		EndIf;
	EndIf;

EndProcedure

Procedure ПодготовитьТелоЗапроса(ПодготовленныйЗапрос, Данные, Файлы, Json, ПараметрыЗаписиJSON)

	СтруктураURL = РазобратьURL(ПодготовленныйЗапрос.URL);

	HTTPRequest = New HTTPRequest;
	HTTPRequest.ResourceAddress = СобратьАдресРесурса(СтруктураURL, ПодготовленныйЗапрос.QueryOptions);
	If ValueIsFilled(Файлы) Then
		ContentType = ЗакодироватьФайлы(HTTPRequest, Файлы, Данные);
	ElsIf ValueIsFilled(Данные) Then
		ContentType = "application/x-www-form-urlencoded";
		If TypeOf(Данные) = Type("BinaryData") Then
			HTTPRequest.SetBodyFromBinaryData(Данные);
		Else
			If TypeOf(Данные) = Type("String") Then
				Тело = Данные;
			Else
				Тело = КодироватьПараметрыЗапроса(Данные);
			EndIf;
			HTTPRequest.SetBodyFromString(Тело, TextEncoding.UTF8, ByteOrderMarkUse.DontUse);
		EndIf;
	ElsIf Json <> Undefined Then
		ContentType = "application/json";
		СтрокаJson = ОбъектВJson(Json, ПодготовленныйЗапрос.ПараметрыПреобразованияJSON, ПараметрыЗаписиJSON);
		HTTPRequest.SetBodyFromString(СтрокаJson, TextEncoding.UTF8, ByteOrderMarkUse.DontUse);
	Else
		ContentType = Undefined;
	EndIf;
	ЗначениеЗаголовка = ЗначениеЗаголовка("content-type", ПодготовленныйЗапрос.Headers);
	If ЗначениеЗаголовка = False And ValueIsFilled(ContentType) Then
		ПодготовленныйЗапрос.Headers.Insert("Content-Type", ContentType);
	EndIf;

	HTTPRequest.Headers = ПодготовленныйЗапрос.Headers;

	УпаковатьЗапрос(HTTPRequest);

	ПодготовленныйЗапрос.Insert("HTTPЗапрос", HTTPRequest);

EndProcedure

Function ЗакодироватьФайлы(HTTPЗапрос, Файлы, Данные)

	Части = New Array;
	If ValueIsFilled(Данные) Then
		For Each Поле In Данные Do
			Части.Add(СоздатьПолеФормы(New Structure("Name,Data", Поле.Key, Поле.Value)));
		EndDo;
	EndIf;
	If TypeOf(Файлы) = Type("Array") Then
		For Each Файл In Файлы Do
			Части.Add(СоздатьПолеФормы(Файл));
		EndDo;
	Else
		Части.Add(СоздатьПолеФормы(Файлы));
	EndIf;

	Разделитель = StrReplace(New UUID, "-", "");
	РазделительСтрок = Chars.CR + Chars.LF;

	ТелоЗапроса = HTTPЗапрос.GetBodyAsStream();
	DataWriter = New DataWriter(ТелоЗапроса, TextEncoding.UTF8, ByteOrder.LittleEndian, "", "", False);
	For Each Часть In Части Do
		DataWriter.WriteLine("--" + Разделитель + РазделительСтрок);
		DataWriter.WriteLine(ЗаголовкиВСтроку(Часть.Headers));
		If TypeOf(Часть.Data) = Type("BinaryData") Then
			DataWriter.Write(Часть.Data);
		Else
			DataWriter.WriteLine(Часть.Data);
		EndIf;
		DataWriter.WriteLine(РазделительСтрок);
	EndDo;
	DataWriter.WriteLine("--" + Разделитель + "--" + РазделительСтрок);
	DataWriter.Close();

	Return StrTemplate("multipart/form-data; boundary=%1", Разделитель);

EndFunction

Function СоздатьПолеФормы(ИсходныеПараметры)

	Поле = New Structure("Name,FileName,Data,Type,Headers");
	Поле.Name = ИсходныеПараметры.Name;
	Поле.Data = ИсходныеПараметры.Data;

	Поле.Type = ЗначениеПоКлючу(ИсходныеПараметры, "Type");
	Поле.Headers = ЗначениеПоКлючу(ИсходныеПараметры, "Headers", New Map);
	Поле.FileName = ЗначениеПоКлючу(ИсходныеПараметры, "FileName");

	Ключ = "Content-Disposition";
	If ЗначениеЗаголовка("content-disposition", Поле.Headers, Ключ) = False Then
		Поле.Headers.Insert("Content-Disposition", "form-data");
	EndIf;

	Части = New Array;
	Части.Add(Поле.Headers[Ключ]);
	Части.Add(StrTemplate("name=""%1""", Поле.Name));
	If ValueIsFilled(Поле.FileName) Then
		Части.Add(StrTemplate("filename=""%1""", Поле.FileName));
	EndIf;

	Поле.Headers[Ключ] = StrConcat(Части, "; ");
	Поле.Headers["Content-Type"] = Поле.Type;

	Return Поле;

EndFunction

Function ЗаполнитьПараметрыЗапроса(Путь)

	ПараметрыЗапроса = New Map;

	Запрос = "";
	РазбитьСтрокуПоРазделителю(Запрос, Путь, "?", True);
	For Each СтрокаКлючРавноПараметр In StrSplit(Запрос, "&", False) Do
		СтрокаКлючРавноПараметр = DecodeString(
			СтрокаКлючРавноПараметр, StringEncodingMethod.URLInURLEncoding);

		ПозицияРавно = StrFind(СтрокаКлючРавноПараметр, "=");
		If ПозицияРавно = 0 Then
			Ключ = СтрокаКлючРавноПараметр;
			Значение = Undefined;
		Else
			Ключ = Left(СтрокаКлючРавноПараметр, ПозицияРавно - 1);
			Значение = Mid(СтрокаКлючРавноПараметр, ПозицияРавно + 1);
		EndIf;

		If ПараметрыЗапроса.Get(Ключ) <> Undefined Then
			If TypeOf(ПараметрыЗапроса[Ключ]) = Type("Array") Then
				ПараметрыЗапроса[Ключ].Add(Значение);
			Else
				Значения = New Array;
				Значения.Add(ПараметрыЗапроса[Ключ]);
				Значения.Add(Значение);
				ПараметрыЗапроса[Ключ] = Значения;
			EndIf;
		Else
			ПараметрыЗапроса.Insert(Ключ, Значение);
		EndIf;

	EndDo;

	Return ПараметрыЗапроса;

EndFunction

Function КодироватьПараметрыЗапроса(ПараметрыЗапроса)

	ЧастиПараметрыЗапроса = New Array;
	For Each Параметр In ПараметрыЗапроса Do
		If TypeOf(Параметр.Value) = Type("Array") Then
			Значения = Параметр.Value;
		Else
			Значения = New Array;
			Значения.Add(Параметр.Value);
		EndIf;

		If Параметр.Value = Undefined Then
			ЧастиПараметрыЗапроса.Add(Параметр.Key);
		Else
			For Each Значение In Значения Do
				ЗначениеПараметра = EncodeString(Значение, StringEncodingMethod.URLEncoding);
				ЧастиПараметрыЗапроса.Add(StrTemplate("%1=%2", Параметр.Key, ЗначениеПараметра));
			EndDo;
		EndIf;
	EndDo;

	Return StrConcat(ЧастиПараметрыЗапроса, "&");

EndFunction

Procedure ПереопределитьМетод(ПодготовленныйЗапрос, Ответ)

	КодыСостоянияHTTP = КодыСостоянияHTTP();

	Метод = ПодготовленныйЗапрос.Method;

	// http://tools.ietf.org/html/rfc7231#section-6.4.4
	If Ответ.StatusCode = КодыСостоянияHTTP.СмотретьДругое_303 And Метод <> "HEAD" Then
		Метод = "GET";
	EndIf;

	// Поведение браузеров
	If Ответ.StatusCode = КодыСостоянияHTTP.ПеремещеноВременно_302 And Метод <> "HEAD" Then
		Метод = "GET";
	EndIf;

	ПодготовленныйЗапрос.Method = Метод;

EndProcedure

Function ОтправитьЗапрос(Сессия, ПодготовленныйЗапрос, Настройки)

	Начало = CurrentUniversalDateInMilliseconds();
	МиллисекундВСекунде = 1000;

	Повтор = 0;
	Длительность = 0;
	Ошибки = New Array;
	
	While True Do
		Try
			Ответ = ОтправитьHTTPЗапрос(Сессия, ПодготовленныйЗапрос, Настройки);
		Except
			ОшибкаВыполненияЗапроса = ErrorInfo();
			
			ТекстОшибки = StrTemplate(
				NStr("ru = 'HTTP %1 %2
				           |Network error:
				           |%3';
							|en = 'HTTP %1 %2
							|Network error:
							|%3';"),
				ПодготовленныйЗапрос.Method,
				ПодготовленныйЗапрос.URL,
				DetailErrorDescription(ErrorInfo())
			);
			Ошибки.Add(ТекстОшибки);
		EndTry;

		Повтор = Повтор + 1;
		Длительность = (CurrentUniversalDateInMilliseconds() - Начало) / МиллисекундВСекунде;

		If Not НеобходимоПовторитьЗапрос(Ответ, Настройки, ОшибкаВыполненияЗапроса) Then
			Break;
		EndIf;

		If Повтор > Настройки.МаксимальноеКоличествоПовторов
			Or Длительность > Настройки.МаксимальноеВремяПовторов Then
			Break;
		EndIf;

		If ОшибкаВыполненияЗапроса <> Undefined
			Or Not ЭтоКодСостоянияПриКоторомНужноУчитыватьЗаголовокRetryAfter(Ответ.StatusCode) Then
			ЗаголовокRetryAfter = False;
		Else
			ЗаголовокRetryAfter = ЗначениеЗаголовка("retry-after", Ответ.Headers);
		EndIf;
		
		If ОшибкаВыполненияЗапроса <> Undefined Then
			Ошибки.Add(КакИсключение(Ответ));
		EndIf;
		
		ДлительностьПриостановки = РассчитатьДлительностьПриостановки(
			Повтор,
			Настройки.КоэффициентЭкспоненциальнойЗадержки,
			ЗаголовокRetryAfter,
			Настройки.МаксимальноеВремяПовторов - Длительность);
		Приостановить(ДлительностьПриостановки);
	EndDo;

	If ОшибкаВыполненияЗапроса <> Undefined Then
		Raise(DetailErrorDescription(ОшибкаВыполненияЗапроса));
	EndIf;

	ЗаголовокContentType = ЗначениеЗаголовка("content-type", Ответ.Headers);
	If ЗаголовокContentType = False Then
		ЗаголовокContentType = "";
	EndIf;

	ПодготовленныйОтвет = НовыйОтвет();
	ПодготовленныйОтвет.Method = ПодготовленныйЗапрос.Method;
	ПодготовленныйОтвет.URL = ПодготовленныйЗапрос.URL;
	ПодготовленныйОтвет.StatusCode = Ответ.StatusCode;
	ПодготовленныйОтвет.Headers = Ответ.Headers;
	ПодготовленныйОтвет.Body = Ответ.GetBodyAsBinaryData();
	ПодготовленныйОтвет.Encoding = КодировкаИзЗаголовка(ЗаголовокContentType);
	ПодготовленныйОтвет.ВремяВыполнения = CurrentUniversalDateInMilliseconds() - Начало;
	ПодготовленныйОтвет.ЭтоПостоянныйРедирект = ЭтоПостоянныйРедирект(Ответ.StatusCode, Ответ.Headers);
	ПодготовленныйОтвет.ЭтоРедирект = ЭтоРедирект(Ответ.StatusCode, Ответ.Headers);
	ПодготовленныйОтвет.Cookies = ИзвлечьCookies(Ответ.Headers, ПодготовленныйЗапрос.URL);
	
	Сессия.Cookies = ОбъединитьCookies(Сессия.Cookies, ПодготовленныйОтвет.Cookies);

	Return ПодготовленныйОтвет;

EndFunction

Function ОтправитьHTTPЗапрос(Сессия, ПодготовленныйЗапрос, Настройки)

	СтруктураURL = РазобратьURL(ПодготовленныйЗапрос.URL);
	Соединение = Соединение(СтруктураURL, ПодготовленныйЗапрос.Аутентификация, Настройки, Сессия);
	Ответ = Соединение.CallHTTPMethod(ПодготовленныйЗапрос.Method, ПодготовленныйЗапрос.HTTPЗапрос);

	For Each Обработчик In ПодготовленныйЗапрос.СобытияНаОтвет Do
		If Обработчик = "ОбработкаОтветаСКодом401" Then
			ОбработкаОтветаСКодом401(Сессия, ПодготовленныйЗапрос, Настройки, Ответ);
		EndIf;
	EndDo;

	Return Ответ;

EndFunction

Function НеобходимоПовторитьЗапрос(Ответ, Настройки, ОшибкаВыполненияЗапроса)

	If Настройки.МаксимальноеКоличествоПовторов < 1 Then
		ПовторитьЗапрос = False;
	ElsIf ОшибкаВыполненияЗапроса <> Undefined Or ПовторятьПриКодеСостояния(Ответ.StatusCode, Настройки) Then
		ПовторитьЗапрос = True;
	Else
		ЗаголовокRetryAfter = ЗначениеЗаголовка("retry-after", Ответ.Headers);
		ПовторитьЗапрос = ЗаголовокRetryAfter <> False
			And ЭтоКодСостоянияПриКоторомНужноУчитыватьЗаголовокRetryAfter(Ответ.StatusCode);
	EndIf;

	Return ПовторитьЗапрос;

EndFunction

Function ПовторятьПриКодеСостояния(КодСостояния, Настройки)

	ПовторПриЛюбомКодеСостоянияБольшеИлиРавным500 = Настройки.ПовторятьДляКодовСостояний = Undefined
		And КодСостояния >= КодыСостоянияHTTP().ВнутренняяОшибкаСервера_500;
	КодСостоянияСоответствуетКодуСостоянияПовтора = TypeOf(Настройки.ПовторятьДляКодовСостояний) = Type("Array")
		And Настройки.ПовторятьДляКодовСостояний.Find(КодСостояния) <> Undefined;
	Return ПовторПриЛюбомКодеСостоянияБольшеИлиРавным500 Or КодСостоянияСоответствуетКодуСостоянияПовтора;

EndFunction

Function ЭтоПостоянныйРедирект(КодСостояния, Заголовки)

	КодыСостоянияHTTP = КодыСостоянияHTTP();

	Return ЕстьЗаголовокLocation(Заголовки)
		And (КодСостояния = КодыСостоянияHTTP.ПеремещеноНавсегда_301
		Or КодСостояния = КодыСостоянияHTTP.ПостоянноеПеренаправление_308);

EndFunction

Function ЭтоРедирект(КодСостояния, Заголовки)

	КодыСостоянияHTTP = КодыСостоянияHTTP();

	СостоянияРедиректа = New Array;
	СостоянияРедиректа.Add(КодыСостоянияHTTP.ПеремещеноНавсегда_301);
	СостоянияРедиректа.Add(КодыСостоянияHTTP.ПеремещеноВременно_302);
	СостоянияРедиректа.Add(КодыСостоянияHTTP.СмотретьДругое_303);
	СостоянияРедиректа.Add(КодыСостоянияHTTP.ВременноеПеренаправление_307);
	СостоянияРедиректа.Add(КодыСостоянияHTTP.ПостоянноеПеренаправление_308);

	Return ЕстьЗаголовокLocation(Заголовки) And СостоянияРедиректа.Find(КодСостояния) <> Undefined;

EndFunction

Procedure УпаковатьЗапрос(Запрос)

	Заголовок = ЗначениеЗаголовка("content-encoding", Запрос.Headers);
	If Заголовок <> False Then
		If Lower(Заголовок) = "gzip" Then
			Запрос.SetBodyFromBinaryData(ЗаписатьGZip(Запрос.GetBodyAsBinaryData()));
		EndIf;
	EndIf;

EndProcedure

Function РаспаковатьОтвет(Ответ)

	Заголовок = ЗначениеЗаголовка("content-encoding", Ответ.Headers);
	If Заголовок <> False Then
		If Lower(Заголовок) = "gzip" Then
			Return ПрочитатьGZip(Ответ.Body);
		EndIf;
	EndIf;

	Return Ответ.Body;

EndFunction

#EndRegion

#Region ОбработчикиСобытий

Procedure ОбработкаОтветаСКодом401(Сессия, ПодготовленныйЗапрос, Настройки, Ответ)

	If ЭтоРедирект(Ответ.StatusCode, Ответ.Headers) Then
		Return;
	EndIf;

	КодыСостоянияHTTP = КодыСостоянияHTTP();
	If Ответ.StatusCode < КодыСостоянияHTTP.НеверныйЗапрос_400
		Or Ответ.StatusCode >= КодыСостоянияHTTP.ВнутренняяОшибкаСервера_500 Then
		Return;
	EndIf;

	Значение = ЗначениеЗаголовка("www-authenticate", Ответ.Headers);
	If Значение <> False And StrFind(Lower(Значение), "digest") Then
		Позиция = StrFind(Lower(Значение), "digest");
		Значение = Mid(Значение, Позиция + StrLen("digest") + 1);
		Значение = StrReplace(Значение, """", "");
		Значение = StrReplace(Значение, Chars.LF, "");

		ПараметрыDigest = New Structure("algorithm,realm,nonce,qop,opaque");
		For Each Часть In РазбитьСтрокуПоСтроке(Значение, ", ") Do
			КлючЗначение = StrSplit(Часть, "=");
			ПараметрыDigest.Insert(КлючЗначение[0], КлючЗначение[1]);
		EndDo;

		Сессия.СлужебныеДанные.ПараметрыDigest = ПараметрыDigest;

		ПодготовленныйЗапрос.Headers.Insert("Authorization", ПодготовитьЗаголовокDigest(Сессия, ПодготовленныйЗапрос));
		ПодготовленныйЗапрос.HTTPЗапрос.Headers = ПодготовленныйЗапрос.Headers;

		Ответ = ОтправитьHTTPЗапрос(Сессия, ПодготовленныйЗапрос, Настройки);
	EndIf;

EndProcedure

#EndRegion

#Region URL

Function ПодготовитьURL(Val URL, ПараметрыЗапроса = Undefined)

	URL = TrimL(URL);

	СтруктураURL = РазобратьURL(URL);

	ПодготовленныйURL = СтруктураURL.Schema + "://";
	If ValueIsFilled(СтруктураURL.Аутентификация.User) Then
		ПодготовленныйURL = ПодготовленныйURL
			+ СтруктураURL.Аутентификация.User + ":"
			+ СтруктураURL.Аутентификация.Password + "@";
	EndIf;
	ПодготовленныйURL = ПодготовленныйURL + СтруктураURL.Server;
	If ValueIsFilled(СтруктураURL.Port) Then
		ПодготовленныйURL = ПодготовленныйURL + ":" + Format(СтруктураURL.Port, "NGS=; NG=");
	EndIf;

	ПодготовленныйURL = ПодготовленныйURL + СобратьАдресРесурса(СтруктураURL, ПараметрыЗапроса);

	Return ПодготовленныйURL;

EndFunction

Function СобратьАдресРесурса(СтруктураURL, ПараметрыЗапроса)

	АдресРесурса = СтруктураURL.Path;

	ОбъединенныеПараметрыЗапроса = Объединить(Скопировать(ПараметрыЗапроса), СтруктураURL.QueryOptions);
	If ValueIsFilled(ОбъединенныеПараметрыЗапроса) Then
		АдресРесурса = АдресРесурса + "?" + КодироватьПараметрыЗапроса(ОбъединенныеПараметрыЗапроса);
	EndIf;
	If ValueIsFilled(СтруктураURL.Particle) Then
		АдресРесурса = АдресРесурса + "#" + СтруктураURL.Particle;
	EndIf;

	Return АдресРесурса;

EndFunction

Function СформироватьНовыйURLПриПеренаправлении(Ответ)

	НовыйURL = ЗначениеЗаголовка("location", Ответ.Headers);
	НовыйURL = DecodeString(НовыйURL, StringEncodingMethod.URLInURLEncoding);

	// Редирект без схемы
	If StrStartsWith(НовыйURL, "//") Then
		СтруктураURL = РазобратьURL(Ответ.URL);
		НовыйURL = СтруктураURL.Schema + ":" + НовыйURL;
	EndIf;

	СтруктураURL = РазобратьURL(НовыйURL);
	If Not ValueIsFilled(СтруктураURL.Server) Then
		СтруктураURLОтвета = РазобратьURL(Ответ.URL);
		БазовыйURL = StrTemplate("%1://%2", СтруктураURLОтвета.Schema, СтруктураURLОтвета.Server);
		If ValueIsFilled(СтруктураURLОтвета.Port) Then
			БазовыйURL = БазовыйURL + ":" + Format(СтруктураURLОтвета.Port, "NGS=; NG=");
		EndIf;
		НовыйURL = БазовыйURL + НовыйURL;
	EndIf;

	Return НовыйURL;

EndFunction

Function ЭтоСтандартныйПорт(СтруктураURL)

	СтандартныйПортHTTP = 80;
	СтандартныйПортHTTPS = 443;

	Return (СтруктураURL.Schema = "http" And СтруктураURL.Port = СтандартныйПортHTTP)
		Or (СтруктураURL.Schema = "https" And СтруктураURL.Port = СтандартныйПортHTTPS);

EndFunction

#EndRegion

#Region РаботаССоединением

Function НастройкиПодключения(Метод, URL, ДополнительныеПараметры)

	РазрешитьПеренаправление =
		ЗначениеПоКлючу(ДополнительныеПараметры, "РазрешитьПеренаправление", Upper(Метод) <> "HEAD");
	ПроверятьSSL = ЗначениеПоКлючу(ДополнительныеПараметры, "ПроверятьSSL", True);
	КлиентскийСертификатSSL = ЗначениеПоКлючу(ДополнительныеПараметры, "КлиентскийСертификатSSL");
	Прокси = ЗначениеПоКлючу(ДополнительныеПараметры, "Proxy", ПроксиПоУмолчанию(URL));
	МаксимальноеКоличествоПовторов = ЗначениеПоКлючу(ДополнительныеПараметры, "МаксимальноеКоличествоПовторов", 0);
	ПовторятьДляКодовСостояний =
		ЗначениеПоКлючу(ДополнительныеПараметры, "ПовторятьДляКодовСостояний", Undefined);
	КоэффициентЭкспоненциальнойЗадержки =
		ЗначениеПоКлючу(ДополнительныеПараметры, "КоэффициентЭкспоненциальнойЗадержки", 1);
	МаксимальноеВремяПовторов = ЗначениеПоКлючу(ДополнительныеПараметры, "МаксимальноеВремяПовторов", 600);

	Настройки = New Structure;
	Настройки.Insert("Timeout", Таймаут(ДополнительныеПараметры));
	Настройки.Insert("РазрешитьПеренаправление", РазрешитьПеренаправление);
	Настройки.Insert("ПроверятьSSL", ПроверятьSSL);
	Настройки.Insert("КлиентскийСертификатSSL", КлиентскийСертификатSSL);
	Настройки.Insert("Proxy", Прокси);
	Настройки.Insert("МаксимальноеКоличествоПовторов", МаксимальноеКоличествоПовторов);
	Настройки.Insert("ПовторятьДляКодовСостояний", ПовторятьДляКодовСостояний);
	Настройки.Insert("КоэффициентЭкспоненциальнойЗадержки", КоэффициентЭкспоненциальнойЗадержки);
	Настройки.Insert("МаксимальноеВремяПовторов", МаксимальноеВремяПовторов);

	Return Настройки;

EndFunction

Function Соединение(ПараметрыСоединения, Аутентификация, ДополнительныеПараметры, Сессия)

	If Not ValueIsFilled(ПараметрыСоединения.Port) Then
		If ПараметрыСоединения.Schema = "https" Then
			ПараметрыСоединения.Port = 443;
		Else
			ПараметрыСоединения.Port = 80;
		EndIf;
	EndIf;

	ЗащищенноеСоединение = Undefined;
	If ПараметрыСоединения.Schema = "https" Then
		ЗащищенноеСоединение = ОбъектЗащищенногоСоединения(ДополнительныеПараметры);
	EndIf;

	Пользователь = "";
	Пароль = "";
	If ValueIsFilled(Аутентификация) Then
		If Аутентификация.Property("User") And Аутентификация.Property("Password") Then
			Пользователь = Аутентификация.User;
			Пароль = Аутентификация.Password;
		EndIf;
	EndIf;

	ИспользоватьАутентификациюОС = Аутентификация.Property("UseOSAuthentication")
		And Аутентификация.UseOSAuthentication = True;

	ПараметрыДляРасчетаИдентификатора = New Array;
	ПараметрыДляРасчетаИдентификатора.Add(ПараметрыСоединения.Server);
	ПараметрыДляРасчетаИдентификатора.Add(ПараметрыСоединения.Port);
	ПараметрыДляРасчетаИдентификатора.Add(Пользователь);
	ПараметрыДляРасчетаИдентификатора.Add(Пароль);
	ПараметрыДляРасчетаИдентификатора.Add(ДополнительныеПараметры.Timeout);
	ПараметрыДляРасчетаИдентификатора.Add(ИспользоватьАутентификациюОС);
	ПараметрыДляРасчетаИдентификатора.Add(ЗащищенноеСоединение);
	ПараметрыДляРасчетаИдентификатора.Add(ДополнительныеПараметры.Proxy);

	If Not Сессия.Property("СлужебныеДанные") Or TypeOf(Сессия.СлужебныеДанные) <> Type("Structure") Then
		Сессия.Insert("СлужебныеДанные", New Structure);
	EndIf;
	If Not Сессия.СлужебныеДанные.Property("ПулСоединений") Then
		Сессия.СлужебныеДанные.Insert("ПулСоединений", New Map);
	EndIf;
	ПулСоединений = Сессия.СлужебныеДанные.ПулСоединений;

	ИдентификаторСоединения = ИдентификаторСоединения(ПараметрыДляРасчетаИдентификатора);

	If ПулСоединений.Get(ИдентификаторСоединения) = Undefined Then
		НовоеСоединение = New HTTPConnection(
			ПараметрыСоединения.Server,
			ПараметрыСоединения.Port,
			Пользователь, Пароль,
			ДополнительныеПараметры.Proxy,
			ДополнительныеПараметры.Timeout,
			ЗащищенноеСоединение,
			ИспользоватьАутентификациюОС);
		ПулСоединений.Insert(ИдентификаторСоединения, НовоеСоединение);
	EndIf;

	Return ПулСоединений[ИдентификаторСоединения];

EndFunction

Function ИдентификаторСоединения(ПараметрыСоединения)

	ПараметрыДляРасчетаИдентификатора = New Array;

	For Each Элемент In ПараметрыСоединения Do
		ТипЭлемента = TypeOf(Элемент);
		If ТипЭлемента = Type("InternetProxy") Then
			ПараметрыДляРасчетаИдентификатора.Add(StrConcat(Элемент.BypassProxyOnAddresses, ""));
			ПараметрыДляРасчетаИдентификатора.Add(XMLString(Элемент.BypassProxyOnLocal));
			ПараметрыДляРасчетаИдентификатора.Add(Элемент.User);
			ПараметрыДляРасчетаИдентификатора.Add(Элемент.Password);
		ElsIf ТипЭлемента = Type("OpenSSLSecureConnection") Then
			// Для упрощения будет считать, что сертификаты в рамках сессии не меняются
			If Элемент.ClientCertificate = Undefined Then
				ПараметрыДляРасчетаИдентификатора.Add("");
			Else
				ПараметрыДляРасчетаИдентификатора.Add(String(TypeOf(Элемент.ClientCertificate)));
			EndIf;
			If Элемент.CertificationAuthorityCertificates = Undefined Then
				ПараметрыДляРасчетаИдентификатора.Add("");
			Else
				ПараметрыДляРасчетаИдентификатора.Add(String(TypeOf(Элемент.CertificationAuthorityCertificates)));
			EndIf;
		Else
			ПараметрыДляРасчетаИдентификатора.Add(XMLString(Элемент));
		EndIf;
	EndDo;

	Return ХешированиеДанных(HashFunction.MD5, StrConcat(ПараметрыДляРасчетаИдентификатора, ""));

EndFunction

Function ОбъектЗащищенногоСоединения(ДополнительныеПараметры)

	If ДополнительныеПараметры.ПроверятьSSL = False Then
		СертификатыУЦ = Undefined;
	ElsIf TypeOf(ДополнительныеПараметры.ПроверятьSSL) = Type("FileCertificationAuthorityCertificates") Then
		СертификатыУЦ = ДополнительныеПараметры.ПроверятьSSL;
	Else
		СертификатыУЦ = New OSCertificationAuthorityCertificates;
	EndIf;
	КлиентскийСертификат = Undefined;
	If TypeOf(ДополнительныеПараметры.КлиентскийСертификатSSL) = Type("FileClientCertificate")
		Or TypeOf(ДополнительныеПараметры.КлиентскийСертификатSSL) = Type("WindowsClientCertificate") Then
		КлиентскийСертификат = ДополнительныеПараметры.КлиентскийСертификатSSL;
	EndIf;

	Return New OpenSSLSecureConnection(КлиентскийСертификат, СертификатыУЦ);

EndFunction

Function Таймаут(ДополнительныеПараметры)

	If ДополнительныеПараметры.Property("Timeout") And ValueIsFilled(ДополнительныеПараметры.Timeout) Then
		Таймаут = ДополнительныеПараметры.Timeout;
	Else
		Таймаут = СтандартныйТаймаут();
	EndIf;

	Return Таймаут;

EndFunction

Function ПроксиПоУмолчанию(URL)

	ПроксиПоУмолчанию = New InternetProxy;
	// BSLLS:ExecuteExternalCodeInCommonModule-off
	ИмяОМПолученияФайловБСП = "ПолучениеФайловИзИнтернета";
	If Metadata.CommonModules.Find(ИмяОМПолученияФайловБСП) <> Undefined Then
		СтруктураURL = РазобратьURL(URL);
		Модуль = Eval(ИмяОМПолученияФайловБСП);
		ПроксиПоУмолчанию = Модуль.ПолучитьПрокси(СтруктураURL.Schema);
	EndIf;
	// BSLLS:ExecuteExternalCodeInCommonModule-on

	Return ПроксиПоУмолчанию;

EndFunction

Function ТекущаяСессия(Сессия)

	If Сессия = Undefined Then
		Сессия = СоздатьСессию();
	EndIf;

	Return Сессия;

EndFunction

#EndRegion

#Region Заголовки

Function ЗаголовкиВСтроку(Заголовки)

	РазделительСтрок = Chars.CR + Chars.LF;
	Строки = New Array;

	СортированныеЗаголовки = "Content-Disposition,Content-Type,Content-Location";
	For Each Ключ In StrSplit(СортированныеЗаголовки, ",") Do
		Значение = ЗначениеЗаголовка(Ключ, Заголовки);
		If Значение <> False And ValueIsFilled(Значение) Then
			Строки.Add(StrTemplate("%1: %2", Ключ, Значение));
		EndIf;
	EndDo;

	Ключи = StrSplit(Upper(СортированныеЗаголовки), ",");
	For Each Заголовок In Заголовки Do
		If Ключи.Find(Upper(Заголовок.Key)) = Undefined Then
			Строки.Add(StrTemplate("%1: %2", Заголовок.Key, Заголовок.Value));
		EndIf;
	EndDo;
	Строки.Add(РазделительСтрок);

	Return StrConcat(Строки, РазделительСтрок);

EndFunction

Procedure УдалитьЗаголовки(Заголовки, СписокЗаголовковСтрокой)

	ЗаголовкиДляУдаления = New Array;
	СписокЗаголовков = StrSplit(СписокЗаголовковСтрокой, ",", False);
	For Each Заголовок In Заголовки Do
		If СписокЗаголовков.Find(Lower(Заголовок.Key)) <> Undefined Then
			ЗаголовкиДляУдаления.Add(Заголовок.Key);
		EndIf;
	EndDo;
	For Each ЗаголовокДляУдаления In ЗаголовкиДляУдаления Do
		Заголовки.Delete(ЗаголовокДляУдаления);
	EndDo;

EndProcedure

Function ЕстьЗаголовокLocation(Заголовки)

	Return ЗначениеЗаголовка("location", Заголовки) <> False;

EndFunction

Function КодировкаИзЗаголовка(Val Заголовок)

	Кодировка = Undefined;

	Заголовок = Lower(TrimAll(Заголовок));
	ИндексРазделителя = StrFind(Заголовок, ";");
	If ИндексРазделителя Then
		ТипСодержимого = TrimAll(Left(Заголовок, ИндексРазделителя - 1));
		КлючКодировки = "charset=";
		ИндексКодировки = StrFind(Заголовок, КлючКодировки);
		If ИндексКодировки Then
			ИндексРазделителя = StrFind(Заголовок, ";", SearchDirection.FromBegin, ИндексКодировки);
			НачальнаяПозиция = ИндексКодировки + StrLen(КлючКодировки);
			If ИндексРазделителя Then
				ДлинаКодировки = ИндексРазделителя - НачальнаяПозиция;
			Else
				ДлинаКодировки = StrLen(Заголовок);
			EndIf;
			Кодировка = Mid(Заголовок, НачальнаяПозиция, ДлинаКодировки);
			Кодировка = StrReplace(Кодировка, """", "");
			Кодировка = StrReplace(Кодировка, "'", "");
		EndIf;
	Else
		ТипСодержимого = Заголовок;
	EndIf;

	If Кодировка = Undefined And StrFind(ТипСодержимого, "text") Then
		Кодировка = "iso-8859-1";
	EndIf;

	Return Кодировка;

EndFunction

Function ЗначениеЗаголовка(Заголовок, ВсеЗаголовки, Ключ = Undefined)

	For Each ОчереднойЗаголовок In ВсеЗаголовки Do
		If Lower(ОчереднойЗаголовок.Key) = Lower(Заголовок) Then
			Ключ = ОчереднойЗаголовок.Key;
			Return ОчереднойЗаголовок.Value;
		EndIf;
	EndDo;

	Return False;

EndFunction

Function СформироватьЗначениеЗаголовкаHost(СтруктураURL)

	Host = СтруктураURL.Server;
	If ValueIsFilled(СтруктураURL.Port) And Not ЭтоСтандартныйПорт(СтруктураURL) Then
		Host = Host + ":" + Format(СтруктураURL.Port, "NGS=; NG=");
	EndIf;

	Return Host;

EndFunction

Function ПодготовитьЗаголовокDigest(Сессия, ПодготовленныйЗапрос)

	ПараметрыDigest = Сессия.СлужебныеДанные.ПараметрыDigest;

	Алгоритм = ОпределитьХешФункцию(ПараметрыDigest.algorithm);
	АлгоритмСтрокой = Upper(ПараметрыDigest.algorithm);
	If Алгоритм = Undefined Then
		Return Undefined;
	EndIf;

	СтруктураURL = РазобратьURL(ПодготовленныйЗапрос.URL);
	Путь = СтруктураURL.Path;
	If ValueIsFilled(СтруктураURL.QueryOptions) Then
		Путь = Путь + "?" + КодироватьПараметрыЗапроса(СтруктураURL.QueryOptions);
	EndIf;

	A1 = StrTemplate("%1:%2:%3",
		ПодготовленныйЗапрос.Аутентификация.User,
		ПараметрыDigest.realm,
		ПодготовленныйЗапрос.Аутентификация.Password);
	A2 = StrTemplate("%1:%2", ПодготовленныйЗапрос.Method, Путь);

	HA1 = ХешированиеДанных(Алгоритм, A1);
	HA2 = ХешированиеДанных(Алгоритм, A2);

	If Not ПараметрыDigest.Property("last_nonce") Then
		ПараметрыDigest.Insert("last_nonce");
	EndIf;

	If ПараметрыDigest.nonce = ПараметрыDigest.last_nonce Then
		ПараметрыDigest.nonce_count = ПараметрыDigest.nonce_count + 1;
	Else
		ПараметрыDigest.Insert("nonce_count", 1);
	EndIf;

	ЗначениеNC = Format(ПараметрыDigest.nonce_count, "ND=8; NLZ=; NG=");
	ЗначениеNonce = Left(StrReplace(Lower(New UUID), "-", ""), 16);

	If АлгоритмСтрокой = "MD5-SESS" Then
		HA1 = ХешированиеДанных(Алгоритм, StrTemplate("%1:%2:%3", HA1, ПараметрыDigest.nonce, ЗначениеNonce));
	EndIf;

	If Not ValueIsFilled(ПараметрыDigest.qop) Then
		ЗначениеResponse = ХешированиеДанных(Алгоритм, StrTemplate("%1:%2:%3", HA1, ПараметрыDigest.nonce, HA2));
	ElsIf ПараметрыDigest.qop = "auth"
		Or StrSplit(ПараметрыDigest.qop, ",", False).Find("auth") <> Undefined Then
		ЗначениеNonceBit = StrTemplate("%1:%2:%3:%4:%5", ПараметрыDigest.nonce, ЗначениеNC, ЗначениеNonce, "auth", HA2);
		ЗначениеResponse = ХешированиеДанных(Алгоритм, StrTemplate("%1:%2", HA1, ЗначениеNonceBit));
	Else
		// INFO: auth-int не реализовано
		Return Undefined;
	EndIf;

	ПараметрыDigest.last_nonce = ПараметрыDigest.nonce;

	База = StrTemplate("username=""%1"", realm=""%2"", nonce=""%3"", uri=""%4"", response=""%5""",
		ПодготовленныйЗапрос.Аутентификация.User,
		ПараметрыDigest.realm,
		ПараметрыDigest.nonce,
		Путь,
		ЗначениеResponse);
	Строки = New Array;
	Строки.Add(База);

	If ValueIsFilled(ПараметрыDigest.opaque) Then
		Строки.Add(StrTemplate(", opaque=""%1""", ПараметрыDigest.opaque));
	EndIf;
	If ValueIsFilled(ПараметрыDigest.algorithm) Then
		Строки.Add(StrTemplate(", algorithm=""%1""", ПараметрыDigest.algorithm));
	EndIf;
	If ValueIsFilled(ПараметрыDigest.qop) Then
		Строки.Add(StrTemplate(", qop=""auth"", nc=%1, cnonce=""%2""", ЗначениеNC, ЗначениеNonce));
	EndIf;

	Return StrTemplate("Digest %1", StrConcat(Строки, ""));

EndFunction

#EndRegion

#Region Cookies

Procedure ПодготовитьCookies(ПодготовленныйЗапрос)

	ЗаголовокCookie = ПодготовитьЗаголовокCookie(ПодготовленныйЗапрос);
	If ValueIsFilled(ЗаголовокCookie) Then
		ПодготовленныйЗапрос.Headers["Cookie"] = ЗаголовокCookie;
	EndIf;

EndProcedure

Function ПодготовитьЗаголовокCookie(ПодготовленныйЗапрос)

	СтруктураURL = РазобратьURL(ПодготовленныйЗапрос.URL);

	Cookies = New Array;
	For Each Cookie In ОтобратьCookiesДляЗапроса(СтруктураURL, ПодготовленныйЗапрос.Cookies) Do
		Cookies.Add(StrTemplate("%1=%2", Cookie.Title, Cookie.Value));
	EndDo;

	Return StrConcat(Cookies, "; ");

EndFunction

Function ОбъединитьCookies(ГлавныйИсточник, ДополнительныйИсточник)

	Cookies = New Map;
	For Each Cookie In ПреобразоватьХранилищеCookiesВМассивCookies(ГлавныйИсточник) Do
		ДобавитьCookieВХранилище(Cookies, Cookie, False);
	EndDo;
	For Each Cookie In ПреобразоватьХранилищеCookiesВМассивCookies(ДополнительныйИсточник) Do
		ДобавитьCookieВХранилище(Cookies, Cookie, False);
	EndDo;

	Return Cookies;

EndFunction

Function ПреобразоватьХранилищеCookiesВМассивCookies(ХранилищеCookies)

	Cookies = New Array;
	If TypeOf(ХранилищеCookies) = Type("Array") Then
		For Each Cookie In ХранилищеCookies Do
			НоваяCookie = КонструкторCookie();
			FillPropertyValues(НоваяCookie, Cookie);
			Cookies.Add(НоваяCookie);
		EndDo;

		Return Cookies;
	EndIf;

	For Each Домен In ХранилищеCookies Do
		For Each Путь In Домен.Value Do
			For Each Наименование In Путь.Value Do
				Cookies.Add(Наименование.Value);
			EndDo;
		EndDo;
	EndDo;

	Return Cookies;

EndFunction

Function ОтобратьCookiesДляЗапроса(СтруктураURL, Cookies)

	СерверВЗапросе = ДобавитьЛидирующуюТочку(СтруктураURL.Server);

	Результат = New Array;
	For Each Домен In Cookies Do
		If Not StrEndsWith(СерверВЗапросе, Домен.Key) Then
			Continue;
		EndIf;
		For Each Путь In Домен.Value Do
			If Not StrStartsWith(СтруктураURL.Path, Путь.Key) Then
				Continue;
			EndIf;
			ЗаполнитьСписокОтфильтрованнымиCookies(Путь.Value, СтруктураURL, Результат);
		EndDo;
	EndDo;

	Return Результат;

EndFunction

Procedure ЗаполнитьСписокОтфильтрованнымиCookies(Cookies, СтруктураURL, Список)

	For Each Cookie In Cookies Do
		If Cookie.Value.ТолькоБезопасноеСоединение = True And СтруктураURL.Schema <> "https" Then
			Continue;
		EndIf;
		// INFO: проверка срока действия игнорируется (Cookie.Значение.СрокДействия)
		// INFO: проверка порта игнорируется

		Список.Add(Cookie.Value);
	EndDo;

EndProcedure

Function ДозаполнитьCookie(Cookies, URL)

	СтруктураURL = РазобратьURL(URL);
	НовыеCookies = New Array;
	If TypeOf(Cookies) = Type("Array") Then
		For Each Cookie In Cookies Do
			НовыйCookie = КонструкторCookie(Cookie.Title, Cookie.Value);
			FillPropertyValues(НовыйCookie, Cookie);

			If Not ValueIsFilled(НовыйCookie.Domain) Then
				НовыйCookie.Domain = СтруктураURL.Server;
			EndIf;
			If Not ValueIsFilled(НовыйCookie.Path) Then
				НовыйCookie.Path = "/";
			EndIf;

			НовыеCookies.Add(НовыйCookie);
		EndDo;

		Return НовыеCookies;
	EndIf;

	Return Cookies;

EndFunction

Function ИзвлечьCookies(Заголовки, URL)

	ТекущееВремя = CurrentUniversalDate();
	Cookies = New Map;
	For Each ОчереднойЗаголовок In Заголовки Do
		If Lower(ОчереднойЗаголовок.Key) = "set-cookie" Then
			For Each ЗаголовокCookie In РазбитьНаОтдельныеЗаголовкиCookies(ОчереднойЗаголовок.Value) Do
				Cookie = РаспарситьCookie(ЗаголовокCookie, URL, ТекущееВремя);
				If Cookie = Undefined Then
					Continue;
				EndIf;
				If Cookie.СрокДействия <= ТекущееВремя Then
					УдалитьCookieИзХранилища(Cookies, Cookie);
				Else
					ДобавитьCookieВХранилище(Cookies, Cookie);
				EndIf;
			EndDo;
		EndIf;
	EndDo;

	Return Cookies;

EndFunction

Function РазбитьНаОтдельныеЗаголовкиCookies(Val Заголовок)

	Заголовки = New Array;

	If Not ValueIsFilled(Заголовок) Then
		Return Заголовки;
	EndIf;

	ЗапчастиЗаголовков = StrSplit(Заголовок, ",", False);

	ОтдельныйЗаголовок = ЗапчастиЗаголовков[0];
	For Индекс = 1 To ЗапчастиЗаголовков.UBound() Do
		ТочкаСЗапятой = StrFind(ЗапчастиЗаголовков[Индекс], ";");
		Равно = StrFind(ЗапчастиЗаголовков[Индекс], "=");
		If ТочкаСЗапятой And Равно And Равно < ТочкаСЗапятой Then
			Заголовки.Add(ОтдельныйЗаголовок);
			ОтдельныйЗаголовок = ЗапчастиЗаголовков[Индекс];
		Else
			ОтдельныйЗаголовок = ОтдельныйЗаголовок + ЗапчастиЗаголовков[Индекс];
		EndIf;
	EndDo;
	Заголовки.Add(ОтдельныйЗаголовок);

	Return Заголовки;

EndFunction

Procedure ДобавитьCookieВХранилище(ХранилищеCookies, Cookie, Замещать = False)

	If ХранилищеCookies.Get(Cookie.Domain) = Undefined Then
		ХранилищеCookies[Cookie.Domain] = New Map;
	EndIf;
	If ХранилищеCookies[Cookie.Domain].Get(Cookie.Path) = Undefined Then
		ХранилищеCookies[Cookie.Domain][Cookie.Path] = New Map;
	EndIf;
	If ХранилищеCookies[Cookie.Domain][Cookie.Path].Get(Cookie.Title) = Undefined Or Замещать Then
		ХранилищеCookies[Cookie.Domain][Cookie.Path][Cookie.Title] = Cookie;
	EndIf;

EndProcedure

Procedure УдалитьCookieИзХранилища(ХранилищеCookies, Cookie)

	If ХранилищеCookies.Get(Cookie.Domain) <> Undefined
		And ХранилищеCookies[Cookie.Domain].Get(Cookie.Path) <> Undefined
		And ХранилищеCookies[Cookie.Domain][Cookie.Path].Get(Cookie.Title) <> Undefined Then
		ХранилищеCookies[Cookie.Domain][Cookie.Path].Delete(Cookie.Title);
	EndIf;

EndProcedure

Function РаспарситьCookie(Заголовок, URL, ТекущееВремя)

	Cookie = Undefined;
	Индекс = 0;

	For Each Параметр In StrSplit(Заголовок, ";", False) Do
		Индекс = Индекс + 1;
		Параметр = TrimAll(Параметр);

		If Индекс = 1 Then
			Cookie = СоздатьCookieИЗаполнитьОсновныеПараметры(Параметр);
			Continue;
		EndIf;

		Части = StrSplit(Параметр, "=", False);
		Ключ = Lower(Части[0]);
		If Части.Count() > 1 Then
			Значение = Части[1];
		EndIf;

		If Ключ = "domain" Then
			Cookie.Domain = Значение;
		ElsIf Ключ = "path" Then
			Cookie.Path = Значение;
		ElsIf Ключ = "secure" Then
			Cookie.ТолькоБезопасноеСоединение = True;
		ElsIf Ключ = "max-age" Then
			СрокДействияMaxAge = ТекущееВремя + ЧислоИзСтроки(Значение);
		ElsIf Ключ = "expires" Then
			Cookie.СрокДействия = ДатаИзСтрокиRFC7231(Значение);
		Else
			Continue;
		EndIf;
	EndDo;
	If ValueIsFilled(Cookie) And ValueIsFilled(СрокДействияMaxAge) Then
		Cookie.СрокДействия = СрокДействияMaxAge;
	EndIf;

	ДозаполнитьCookieНеявнымиЗначениями(Cookie, URL);

	Return Cookie;

EndFunction

Function СоздатьCookieИЗаполнитьОсновныеПараметры(Параметр)

	Части = StrSplit(Параметр, "=", False);
	Наименование = Части[0];
	If Части.Count() > 1 Then
		Значение = Части[1];
	EndIf;

	Return КонструкторCookie(Наименование, Значение);

EndFunction

Procedure ДозаполнитьCookieНеявнымиЗначениями(Cookie, URL)

	If Cookie = Undefined Then
		Return;
	EndIf;

	СтруктураURL = РазобратьURL(URL);
	If Not ValueIsFilled(Cookie.Domain) Then
		Cookie.Domain = СтруктураURL.Server;
	EndIf;
	If Not ValueIsFilled(Cookie.Port) And ValueIsFilled(СтруктураURL.Port) Then
		Cookie.Port = СтруктураURL.Port;
	EndIf;
	If Not ValueIsFilled(Cookie.Path) Then
		ПозицияПоследнегоСлеша = StrFind(СтруктураURL.Path, "/", SearchDirection.FromEnd);
		If ПозицияПоследнегоСлеша <= 1 Then
			Cookie.Path = "/";
		Else
			Cookie.Path = Left(СтруктураURL.Path, ПозицияПоследнегоСлеша - 1);
		EndIf;
	EndIf;

EndProcedure

Function КонструкторCookie(Наименование = "", Значение = Undefined)

	НовыйCookie = New Structure;
	НовыйCookie.Insert("Description", Наименование);
	НовыйCookie.Insert("Value", Значение);
	НовыйCookie.Insert("Domain", "");
	НовыйCookie.Insert("Path", "");
	НовыйCookie.Insert("Port");
	НовыйCookie.Insert("СрокДействия", '39990101');
	НовыйCookie.Insert("ТолькоБезопасноеСоединение");

	Return НовыйCookie;

EndFunction

#EndRegion

#Region ПараметрыРаботыСJSON

// Преобразует значение типа к типу, сериализация которого поддерживается.
//
// Parameters:
//   Свойство - String - имя свойства, если выполняется запись структуры или соответствия.
//   Значение - Arbitrary - исходное значение.
//   ДополнительныеПараметры - Arbitrary - дополнительные параметры, которые указаны в вызове метода ЗаписатьJSON.
//   Отказ - Boolean - отказ от записи свойства.
//
// Returns:
//   Arbitrary - см. типы ЗаписатьJSON.
//
Function ПреобразованиеJson(Свойство, Значение, ДополнительныеПараметры, Отказ) Export

	If TypeOf(Значение) = Type("UUID") Then
		Return String(Значение);
	ElsIf TypeOf(Значение) = Type("BinaryData") Then
		Return GetBase64StringFromBinaryData(Значение);
	Else
		// Если значение не поддерживает сериализацию в JSON, то будет выброшено исключение
		Return Значение;
	EndIf;

EndFunction

// Восстанавливает значение типа, десериализация которого не поддерживается.
//
// Parameters:
//   Свойство - String - имя свойства, значение которого нужно восстановить.
//   Значение - String - значение, которое нужно восстановить.
//   ТипыСвойств - Map - типы свойств, которые нужно восстановить.
//     * Ключ - Строка - имя свойства. Равно значению параметра Свойство.
//     * Значение - Тип - исходный тип значения.
//
// Returns:
//   Arbitrary - восстановленное значение.
//
Function ВосстановлениеJson(Свойство, Значение, ТипыСвойств) Export

	ТипСвойства = ТипыСвойств.Get(Свойство);
	If ТипСвойства = Type("UUID") Then
		Return New UUID(Значение);
	ElsIf ТипСвойства = Type("BinaryData") Then
		Return GetBinaryDataFromBase64String(Значение);
	Else
		Return Значение;
	EndIf;

EndFunction

#EndRegion

#Region АутентификацияAWS4

Function КлючПодписиAWS4(СекретныйКлюч, Дата, Регион, Сервис)

	КлючДата = ПодписатьСообщениеHMAC("AWS4" + СекретныйКлюч, Дата);
	КлючРегион = ПодписатьСообщениеHMAC(КлючДата, Регион);
	КлючСервис = ПодписатьСообщениеHMAC(КлючРегион, Сервис);

	Return ПодписатьСообщениеHMAC(КлючСервис, "aws4_request");

EndFunction

Function ПодписатьСообщениеHMAC(Val Ключ, Val Сообщение, Val Алгоритм = Undefined)

	If Алгоритм = Undefined Then
		Алгоритм = HashFunction.SHA256;
	EndIf;

	If TypeOf(Ключ) = Type("String") Then
		Ключ = GetBinaryDataFromString(Ключ, TextEncoding.UTF8, False);
	EndIf;
	If TypeOf(Сообщение) = Type("String") Then
		Сообщение = GetBinaryDataFromString(Сообщение, TextEncoding.UTF8, False);
	EndIf;

	Return HMAC(Ключ, Сообщение, Алгоритм);

EndFunction

Procedure ПодготовитьАутентификациюAWS4(ПодготовленныйЗапрос)

	ЗначениеЗаголовка = ЗначениеЗаголовка("x-amz-date", ПодготовленныйЗапрос.Headers);
	If ЗначениеЗаголовка <> False Then
		ТекущееВремя = Date(StrReplace(StrReplace(ЗначениеЗаголовка, "T", ""), "Z", ""));
	Else
		ТекущееВремя = CurrentUniversalDate();
	EndIf;
	ПодготовленныйЗапрос.Headers["x-amz-date"] = Format(ТекущееВремя, "DF=yyyyMMddTHHmmssZ");
	ОбластьДействияДата = Format(ТекущееВремя, "DF=yyyyMMdd");

	ПодготовленныйЗапрос.Headers["x-amz-content-sha256"] =
		ХешированиеДанных(HashFunction.SHA256, ПодготовленныйЗапрос.HTTPЗапрос.GetBodyAsStream());

	СтруктураURL = РазобратьURL(ПодготовленныйЗапрос.URL);

	КаноническиеЗаголовки = КаноническиеЗаголовкиAWS4(ПодготовленныйЗапрос.Headers, СтруктураURL);

	КаноническийПуть = СтруктураURL.Path;
	КаноническиеПараметрыЗапроса = КаноническиеПараметрыЗапросаAWS4(СтруктураURL.QueryOptions);

	ЧастиЗапроса = New Array;
	ЧастиЗапроса.Add(ПодготовленныйЗапрос.Method);
	ЧастиЗапроса.Add(КаноническийПуть);
	ЧастиЗапроса.Add(КаноническиеПараметрыЗапроса);
	ЧастиЗапроса.Add(КаноническиеЗаголовки.КаноническиеЗаголовки);
	ЧастиЗапроса.Add(КаноническиеЗаголовки.ПодписываемыеЗаголовки);
	ЧастиЗапроса.Add(ПодготовленныйЗапрос.Headers["x-amz-content-sha256"]);
	КаноническийЗапрос = StrConcat(ЧастиЗапроса, Chars.LF);

	ЧастиОбластиДействия = New Array;
	ЧастиОбластиДействия.Add(ОбластьДействияДата);
	ЧастиОбластиДействия.Add(ПодготовленныйЗапрос.Аутентификация.State);
	ЧастиОбластиДействия.Add(ПодготовленныйЗапрос.Аутентификация.Service);
	ЧастиОбластиДействия.Add("aws4_request");
	ОбластьДействия = StrConcat(ЧастиОбластиДействия, "/");

	ЧастиСтрокиДляПодписи = New Array;
	ЧастиСтрокиДляПодписи.Add(ПодготовленныйЗапрос.Аутентификация.Type);
	ЧастиСтрокиДляПодписи.Add(ПодготовленныйЗапрос.Headers["x-amz-date"]);
	ЧастиСтрокиДляПодписи.Add(ОбластьДействия);
	ЧастиСтрокиДляПодписи.Add(ХешированиеДанных(HashFunction.SHA256, КаноническийЗапрос));
	СтрокаДляПодписи = StrConcat(ЧастиСтрокиДляПодписи, Chars.LF);

	Ключ = КлючПодписиAWS4(
		ПодготовленныйЗапрос.Аутентификация.СекретныйКлюч,
		ОбластьДействияДата,
		ПодготовленныйЗапрос.Аутентификация.State,
		ПодготовленныйЗапрос.Аутентификация.Service);
	Подпись = Lower(GetHexStringFromBinaryData(ПодписатьСообщениеHMAC(Ключ, СтрокаДляПодписи)));

	ПодготовленныйЗапрос.Headers["Authorization"] = StrTemplate(
		"%1 Credential=%2/%3, SignedHeaders=%4, Signature=%5",
		ПодготовленныйЗапрос.Аутентификация.Type,
		ПодготовленныйЗапрос.Аутентификация.ИдентификаторКлючаДоступа,
		ОбластьДействия,
		КаноническиеЗаголовки.ПодписываемыеЗаголовки,
		Подпись);

	ПодготовленныйЗапрос.HTTPЗапрос.Headers = ПодготовленныйЗапрос.Headers;

EndProcedure

Function КаноническиеЗаголовкиAWS4(Заголовки, СтруктураURL)

	Список = New ValueList;

	ЗаголовокHostЕстьВЗапросе = False;
	ЗаголовкиПоУмолчанию = ЗаголовкиПоУмолчаниюAWS4();
	For Each ОчереднойЗаголовок In Заголовки Do
		Заголовок = Lower(ОчереднойЗаголовок.Key);
		If ЗаголовкиПоУмолчанию.Исключения.Find(Заголовок) <> Undefined Then
			Continue;
		EndIf;
		ЗаголовокHostЕстьВЗапросе = Max(ЗаголовокHostЕстьВЗапросе, Заголовок = "host");

		If ЗаголовкиПоУмолчанию.Equal.Find(Заголовок) <> Undefined Then
			Список.Add(Заголовок, TrimAll(ОчереднойЗаголовок.Value));
		Else
			For Each Префикс In ЗаголовкиПоУмолчанию.BeginsWith Do
				If StrStartsWith(Заголовок, Префикс) Then
					Список.Add(Заголовок, TrimAll(ОчереднойЗаголовок.Value));
					Break;
				EndIf;
			EndDo;
		EndIf;
	EndDo;

	If Not ЗаголовокHostЕстьВЗапросе Then
		Список.Add("host", СформироватьЗначениеЗаголовкаHost(СтруктураURL));
	EndIf;

	Список.SortByValue(SortDirection.Asc);

	КаноническиеЗаголовки = New Array;
	ПодписываемыеЗаголовки = New Array;
	For Each ЭлементСписка In Список Do
		КаноническиеЗаголовки.Add(ЭлементСписка.Value + ":" + ЭлементСписка.Presentation);
		ПодписываемыеЗаголовки.Add(ЭлементСписка.Value);
	EndDo;
	КаноническиеЗаголовки.Add("");

	КаноническиеЗаголовки = StrConcat(КаноническиеЗаголовки, Chars.LF);
	ПодписываемыеЗаголовки = StrConcat(ПодписываемыеЗаголовки, ";");
	Return New Structure(
		"КаноническиеЗаголовки, ПодписываемыеЗаголовки",
		КаноническиеЗаголовки, ПодписываемыеЗаголовки);

EndFunction

Function КаноническиеПараметрыЗапросаAWS4(ПараметрыЗапроса)

	Список = New ValueList;
	For Each ОчереднойПараметрЗапроса In ПараметрыЗапроса Do
		Список.Add(ОчереднойПараметрЗапроса.Key, TrimAll(ОчереднойПараметрЗапроса.Value));
	EndDo;
	Список.SortByValue(SortDirection.Asc);

	КаноническиеПараметры = New Array;
	For Each ЭлементСписка In Список Do
		ЗначениеПараметра = EncodeString(ЭлементСписка.Presentation, StringEncodingMethod.URLEncoding);
		КаноническиеПараметры.Add(ЭлементСписка.Value + "=" + ЗначениеПараметра);
	EndDo;

	Return StrConcat(КаноническиеПараметры, "&");

EndFunction

Function ЗаголовкиПоУмолчаниюAWS4()

	Заголовки = New Structure;
	Заголовки.Insert("Equal", StrSplit("host,content-type,date", ","));
	Заголовки.Insert("BeginsWith", StrSplit("x-amz-", ","));
	Заголовки.Insert("Исключения", StrSplit("x-amz-client-context", ","));

	Return Заголовки;

EndFunction

#EndRegion

#Region КодированиеДекодированиеДанных

#Region СлужебныеСтруктурыZip

// Описание структур см. здесь https://pkware.cachefly.net/webdocs/casestudies/APPNOTE.TXT

Function ZipРазмерLFH()

	Return 34;

EndFunction

Function ZipРазмерDD()

	Return 16;

EndFunction

Function ZipРазмерCDH()

	Return 50;

EndFunction

Function ZipРазмерEOCD()

	Return 22;

EndFunction

Function ZipLFH()

	// Local file header
	Буфер = New BinaryDataBuffer(ZipРазмерLFH());
	Буфер.WriteInt32(0, 67324752); // signature 0x04034b50
	Буфер.WriteInt16(4, 20);       // version
	Буфер.WriteInt16(6, 10);       // bit flags
	Буфер.WriteInt16(8, 8);        // compression method
	Буфер.WriteInt16(10, 0);       // time
	Буфер.WriteInt16(12, 0);       // date
	Буфер.WriteInt32(14, 0);       // crc-32
	Буфер.WriteInt32(18, 0);       // compressed size
	Буфер.WriteInt32(22, 0);       // uncompressed size
	Буфер.WriteInt16(26, 4);       // filename legth - "data"
	Буфер.WriteInt16(28, 0);       // extra field length
	Буфер.Write(30, GetBinaryDataBufferFromString("data", "ascii", False));

	Return Буфер;

EndFunction

Function ZipDD(CRC32, РазмерСжатыхДанных, РазмерНесжатыхДанных)

	// Data descriptor
	Буфер = New BinaryDataBuffer(ZipРазмерDD());
	Буфер.WriteInt32(0, 134695760);
	Буфер.WriteInt32(4, CRC32);
	Буфер.WriteInt32(8, РазмерСжатыхДанных);
	Буфер.WriteInt32(12, РазмерНесжатыхДанных);

	Return Буфер;

EndFunction

Function ZipCDH(CRC32, РазмерСжатыхДанных, РазмерНесжатыхДанных)

	// Central directory header
	Буфер = New BinaryDataBuffer(ZipРазмерCDH());
	Буфер.WriteInt32(0, 33639248);              // signature 0x02014b50
	Буфер.WriteInt16(4, 798);                   // version made by
	Буфер.WriteInt16(6, 20);                    // version needed to extract
	Буфер.WriteInt16(8, 10);                    // bit flags
	Буфер.WriteInt16(10, 8);                    // compression method
	Буфер.WriteInt16(12, 0);                    // time
	Буфер.WriteInt16(14, 0);                    // date
	Буфер.WriteInt32(16, CRC32);                // crc-32
	Буфер.WriteInt32(20, РазмерСжатыхДанных);   // compressed size
	Буфер.WriteInt32(24, РазмерНесжатыхДанных); // uncompressed size
	Буфер.WriteInt16(28, 4);                    // file name length
	Буфер.WriteInt16(30, 0);                    // extra field length
	Буфер.WriteInt16(32, 0);                    // file comment length
	Буфер.WriteInt16(34, 0);                    // disk number start
	Буфер.WriteInt16(36, 0);                    // internal file attributes
	Буфер.WriteInt32(38, 2176057344);           // external file attributes
	Буфер.WriteInt32(42, 0);                    // relative offset of local header
	Буфер.Write(46, GetBinaryDataBufferFromString("data", "ascii", False));

	Return Буфер;

EndFunction

Function ZipEOCD(РазмерСжатыхДанных)

	// End of central directory
	РазмерCDH = 50;
	Буфер = New BinaryDataBuffer(ZipРазмерEOCD());
	Буфер.WriteInt32(0, 101010256); // signature 0x06054b50
	Буфер.WriteInt16(4, 0); // number of this disk
	Буфер.WriteInt16(6, 0); // number of the disk with the start of the central directory
	Буфер.WriteInt16(8, 1); // total number of entries in the central directory on this disk
	Буфер.WriteInt16(10, 1); // total number of entries in the central directory
	Буфер.WriteInt32(12, РазмерCDH); // size of the central directory
	// offset of start of central directory with respect to the starting disk number
	Буфер.WriteInt32(16, ZipРазмерLFH() + РазмерСжатыхДанных + ZipРазмерDD());
	Буфер.WriteInt16(20, 0); // the starting disk number

	Return Буфер;

EndFunction

#EndRegion

#Region СлужебныеСтруктурыGZip

// Описание структур см. здесь https://www.ietf.org/rfc/rfc1952.txt

Function GZipРазмерHeader()

	Return 10;

EndFunction

Function GZipРазмерFooter()

	Return 8;

EndFunction

Function GZipHeader()

	Буфер = New BinaryDataBuffer(GZipРазмерHeader());
	Буфер[0] = 31;               // ID1 0x1f
	Буфер[1] = 139;              // ID2 0x8b
	Буфер[2] = 8;                // compression method (08 for DEFLATE)
	Буфер[3] = 0;                // header flags
	Буфер.WriteInt32(4, 0); // timestamp
	Буфер[8] = 0;                // compression flags
	Буфер[9] = 255;              // operating system ID

	Return Буфер;

EndFunction

Function GZipFooter(CRC32, РазмерИсходныхДанных)

	Буфер = New BinaryDataBuffer(GZipРазмерFooter());
	Буфер.WriteInt32(0, CRC32);
	Буфер.WriteInt32(4, РазмерИсходныхДанных);

	Return Буфер;

EndFunction

#EndRegion

Function ПрочитатьZip(СжатыеДанные, ТекстОшибки = Undefined)

#If MobileAppServer Then
	Raise(NStr("ru = 'Работа с Zip-файлами в мобильной платформе не поддерживается';
							|en = 'Работа с Zip-файлами в мобильной платформе не поддерживается';"));
#Else
	Каталог = GetTempFileName();
	ЧтениеZip = New ZipFileReader(СжатыеДанные);
	ИмяФайла = ЧтениеZip.Items[0].Name;
	Try
		ЧтениеZip.Extract(ЧтениеZip.Items[0], Каталог, ZIPRestoreFilePathsMode.DontRestore);
	Except
		// Игнорируем проверку целостности архива, просто читаем результат
		ТекстОшибки = DetailErrorDescription(ErrorInfo());
	EndTry;
	ЧтениеZip.Close();

	Результат = New BinaryData(Каталог + GetPathSeparator() + ИмяФайла);
	DeleteFiles(Каталог);

	Return Результат;
#EndIf

EndFunction

Function ЗаписатьZip(Данные)

#If MobileAppServer Then
	Raise(NStr("ru = 'Работа с Zip-файлами в мобильной платформе не поддерживается';
							|en = 'Работа с Zip-файлами в мобильной платформе не поддерживается';"));
#Else
	ВременныйФайл = GetTempFileName(".bin");
	Данные.Write(ВременныйФайл);
	ПотокZip = New MemoryStream;
	ЗаписьZip = New ZipFileWriter(ПотокZip);
	ЗаписьZip.Add(ВременныйФайл);
	ЗаписьZip.Write();
	DeleteFiles(ВременныйФайл);

	Return ПотокZip.CloseAndGetBinaryData();
#EndIf

EndFunction

#EndRegion

#Region ПараметрыПоУмолчанию

Function ЗаголовкиПоУмолчанию()

	Заголовки = New Map;
#If MobileAppServer Then
	Заголовки.Insert("Accept-Encoding", "identity");
#Else
	Заголовки.Insert("Accept-Encoding", "gzip");
#EndIf
	Заголовки.Insert("Accept", "*/*");
	Заголовки.Insert("Connection", "keep-alive");

	Return Заголовки;

EndFunction

Function МаксимальноеКоличествоПеренаправлений()

	Return 30;

EndFunction

Function СтандартныйТаймаут()

	Return 30;

EndFunction

Function ПараметрыПреобразованияJSONПоУмолчанию()

	ПараметрыПреобразованияПоУмолчанию = New Structure;
	ПараметрыПреобразованияПоУмолчанию.Insert("ПрочитатьВСоответствие", True);
	ПараметрыПреобразованияПоУмолчанию.Insert("ФорматДатыJSON", JSONDateFormat.ISO);
	ПараметрыПреобразованияПоУмолчанию.Insert("ИменаСвойствСоЗначениямиДата", Undefined);
	ПараметрыПреобразованияПоУмолчанию.Insert("ВариантЗаписиДатыJSON", JSONDateWritingVariant.LocalDate);
	ПараметрыПреобразованияПоУмолчанию.Insert("ИмяФункцииПреобразования", Undefined);
	ПараметрыПреобразованияПоУмолчанию.Insert("МодульФункцииПреобразования", Undefined);
	ПараметрыПреобразованияПоУмолчанию.Insert("ДополнительныеПараметрыФункцииПреобразования", Undefined);
	ПараметрыПреобразованияПоУмолчанию.Insert("ИмяФункцииВосстановления", Undefined);
	ПараметрыПреобразованияПоУмолчанию.Insert("МодульФункцииВосстановления", Undefined);
	ПараметрыПреобразованияПоУмолчанию.Insert("ДополнительныеПараметрыФункцииВосстановления", Undefined);
	ПараметрыПреобразованияПоУмолчанию.Insert("ИменаСвойствДляОбработкиВосстановления", Undefined);
	ПараметрыПреобразованияПоУмолчанию.Insert("МаксимальнаяВложенность", 500);

	Return ПараметрыПреобразованияПоУмолчанию;

EndFunction

Function ПараметрыЗаписиJSONПоУмолчанию()

	ПараметрыЗаписиJSONПоУмолчанию = New Structure;
	ПараметрыЗаписиJSONПоУмолчанию.Insert("NewLines", JSONLineBreak.Auto);
	ПараметрыЗаписиJSONПоУмолчанию.Insert("IndentChars", " ");
	ПараметрыЗаписиJSONПоУмолчанию.Insert("UseDoubleQuotes", True);
	ПараметрыЗаписиJSONПоУмолчанию.Insert("EscapeCharacters", JSONCharactersEscapeMode.None);
	ПараметрыЗаписиJSONПоУмолчанию.Insert("EscapeAngleBrackets", False);
	ПараметрыЗаписиJSONПоУмолчанию.Insert("EscapeLineTerminators", True);
	ПараметрыЗаписиJSONПоУмолчанию.Insert("EscapeAmpersand", False);
	ПараметрыЗаписиJSONПоУмолчанию.Insert("EscapeSingleQuotes", False);
	ПараметрыЗаписиJSONПоУмолчанию.Insert("EscapeSlash", False);

	Return ПараметрыЗаписиJSONПоУмолчанию;

EndFunction

#EndRegion

#Region КодыСостояний

Function ОписанияКодовСостоянийHTTP()

	Коды = New Array;
	Коды.Add(НовыйКодHTTP(100, "Продолжай_100", "Continue"));
	Коды.Add(НовыйКодHTTP(101, "ПереключениеПротокола_101", "Switching Protocols"));
	Коды.Add(НовыйКодHTTP(102, "ИдетОбработка_102", "Processing"));
	Коды.Add(НовыйКодHTTP(103, "РанняяМетаинформация_103", "Early Hints"));

	Коды.Add(НовыйКодHTTP(200, "ОК_200", "OK"));
	Коды.Add(НовыйКодHTTP(201, "Создано_201", "Created"));
	Коды.Add(НовыйКодHTTP(202, "Принято_202", "Accepted"));
	Коды.Add(НовыйКодHTTP(203, "ИнформацияНеАвторитетна_203", "Non-Authoritative Information"));
	Коды.Add(НовыйКодHTTP(204, "НетСодержимого_204", "No Content"));
	Коды.Add(НовыйКодHTTP(205, "СброситьСодержимое_205", "Reset Content"));
	Коды.Add(НовыйКодHTTP(206, "ЧастичноеСодержимое_206", "Partial Content"));
	Коды.Add(НовыйКодHTTP(207, "Многостатусный_207", "Multi-Status"));
	Коды.Add(НовыйКодHTTP(208, "УжеСообщалось_208", "Already Reported"));
	Коды.Add(НовыйКодHTTP(226, "ИспользованоIM_226", "IM Used"));

	Коды.Add(НовыйКодHTTP(300, "МножествоВыборов_300", "Multiple Choices"));
	Коды.Add(НовыйКодHTTP(301, "ПеремещеноНавсегда_301", "Moved Permanently"));
	Коды.Add(НовыйКодHTTP(302, "ПеремещеноВременно_302", "Moved Temporarily"));
	Коды.Add(НовыйКодHTTP(303, "СмотретьДругое_303", "See Other"));
	Коды.Add(НовыйКодHTTP(304, "НеИзменялось_304", "Not Modified"));
	Коды.Add(НовыйКодHTTP(305, "ИспользоватьПрокси_305", "Use Proxy"));
	Коды.Add(НовыйКодHTTP(307, "ВременноеПеренаправление_307", "Temporary Redirect"));
	Коды.Add(НовыйКодHTTP(308, "ПостоянноеПеренаправление_308", "Permanent Redirect"));

	Коды.Add(НовыйКодHTTP(400, "НеверныйЗапрос_400", "Bad Request"));
	Коды.Add(НовыйКодHTTP(401, "НеАвторизован_401", "Unauthorized"));
	Коды.Add(НовыйКодHTTP(402, "НеобходимаОплата_402", "Payment Required"));
	Коды.Add(НовыйКодHTTP(403, "Запрещено_403", "Forbidden"));
	Коды.Add(НовыйКодHTTP(404, "НеНайдено_404", "Not Found"));
	Коды.Add(НовыйКодHTTP(405, "МетодНеПоддерживается_405", "Method Not Allowed"));
	Коды.Add(НовыйКодHTTP(406, "Неприемлемо_406", "Not Acceptable"));
	Коды.Add(НовыйКодHTTP(407, "НеобходимаАутентификацияПрокси_407", "Proxy Authentication Required"));
	Коды.Add(НовыйКодHTTP(408, "ИстеклоВремяОжидания_408", "Request Timeout"));
	Коды.Add(НовыйКодHTTP(409, "Конфликт_409", "Conflict"));
	Коды.Add(НовыйКодHTTP(410, "Удален_410", "Gone"));
	Коды.Add(НовыйКодHTTP(411, "НеобходимаДлина_411", "Length Required"));
	Коды.Add(НовыйКодHTTP(412, "УсловиеЛожно_412", "Precondition Failed"));
	Коды.Add(НовыйКодHTTP(413, "ПолезнаяНагрузкаСлишкомВелика_413", "Payload Too Large"));
	Коды.Add(НовыйКодHTTP(414, "СлишкомДлинныйURI_414", "URI Too Long"));
	Коды.Add(НовыйКодHTTP(415, "НеподдерживаемыйТипДанных_415", "Unsupported Media Type"));
	Коды.Add(НовыйКодHTTP(416, "ДиапазонНеДостижим_416", "Range Not Satisfiable"));
	Коды.Add(НовыйКодHTTP(417, "ОжиданиеНеУдалось_417", "Expectation Failed"));
	Коды.Add(НовыйКодHTTP(419, "ОшибкаПроверкиCSRF_419", "Authentication Timeout"));
	Коды.Add(НовыйКодHTTP(421, "НеправильноНаправленныйЗапрос_421", "Misdirected Request"));
	Коды.Add(НовыйКодHTTP(422, "НеобрабатываемыйЭкземпляр_422", "Unprocessable Entity"));
	Коды.Add(НовыйКодHTTP(423, "Заблокировано_423", "Locked"));
	Коды.Add(НовыйКодHTTP(424, "НевыполненнаяЗависимость_424", "Failed Dependency"));
	Коды.Add(НовыйКодHTTP(425, "СлишкомРано_425", "Too Early"));
	Коды.Add(НовыйКодHTTP(426, "НеобходимоОбновление_426", "Upgrade Required"));
	Коды.Add(НовыйКодHTTP(428, "НеобходимоПредусловие_428", "Precondition Required"));
	Коды.Add(НовыйКодHTTP(429, "СлишкомМногоЗапросов_429", "Too Many Requests"));
	Коды.Add(НовыйКодHTTP(431, "ПоляЗаголовкаЗапросаСлишкомБольшие_431", "Request Header Fields Too Large"));
	Коды.Add(НовыйКодHTTP(449, "ПовторитьС_449", "Retry With"));
	Коды.Add(НовыйКодHTTP(451, "НедоступноПоЮридическимПричинам_451", "Unavailable For Legal Reasons"));
	Коды.Add(НовыйКодHTTP(499, "КлиентЗакрылСоединение_499", "Client Closed Request"));

	Коды.Add(НовыйКодHTTP(500, "ВнутренняяОшибкаСервера_500", "Internal Server Error"));
	Коды.Add(НовыйКодHTTP(501, "НеРеализовано_501", "Not Implemented"));
	Коды.Add(НовыйКодHTTP(502, "ОшибочныйШлюз_502", "Bad Gateway"));
	Коды.Add(НовыйКодHTTP(503, "СервисНедоступен_503", "Service Unavailable"));
	Коды.Add(НовыйКодHTTP(504, "ШлюзНеОтвечает_504", "Gateway Timeout"));
	Коды.Add(НовыйКодHTTP(505, "ВерсияHTTPНеПоддерживается_505", "HTTP Version Not Supported"));
	Коды.Add(НовыйКодHTTP(506, "ВариантТожеПроводитСогласование_506", "Variant Also Negotiates"));
	Коды.Add(НовыйКодHTTP(507, "ПереполнениеХранилища_507", "Insufficient Storage"));
	Коды.Add(НовыйКодHTTP(508, "ОбнаруженоБесконечноеПеренаправление_508", "Loop Detected"));
	Коды.Add(НовыйКодHTTP(509, "ИсчерпанаПропускнаяШиринаКанала_509", "Bandwidth Limit Exceeded"));
	Коды.Add(НовыйКодHTTP(510, "НеРасширено_510", "Not Extended"));
	Коды.Add(НовыйКодHTTP(511, "ТребуетсяСетеваяАутентификация_511", "Network Authentication Required"));
	Коды.Add(НовыйКодHTTP(520, "НеизвестнаяОшибка_520", "Unknown Error"));
	Коды.Add(НовыйКодHTTP(521, "ВебСерверНеРаботает_521", "Web Server Is Down"));
	Коды.Add(НовыйКодHTTP(522, "СоединениеНеОтвечает_522", "Connection Timed Out"));
	Коды.Add(НовыйКодHTTP(523, "ИсточникНедоступен_523", "Origin Is Unreachable"));
	Коды.Add(НовыйКодHTTP(524, "ВремяОжиданияИстекло_524", "A Timeout Occurred"));
	Коды.Add(НовыйКодHTTP(525, "КвитированиеSSНеУдалось_525", "SSL Handshake Failed"));
	Коды.Add(НовыйКодHTTP(526, "НедействительныйСертификатSSL_526", "Invalid SSL Certificate"));

	Return Коды;

EndFunction

Function НовыйКодHTTP(Код, Ключ, Описание)

	Return New Structure("Code, Key, Description", Код, Ключ, Описание);

EndFunction

Function ЭтоКодСостоянияПриКоторомНужноУчитыватьЗаголовокRetryAfter(КодСостояния)

	Коды = КодыСостоянияHTTP();
	Return КодСостояния = Коды.ПолезнаяНагрузкаСлишкомВелика_413
		Or КодСостояния = Коды.СлишкомМногоЗапросов_429
		Or КодСостояния = Коды.СервисНедоступен_503;

EndFunction

#EndRegion

#Region Прочие

Function ОпределитьХешФункцию(Val Алгоритм)

	Алгоритм = Upper(Алгоритм);
	If Not ValueIsFilled(Алгоритм) Or Алгоритм = "MD5" Or Алгоритм = "MD5-SESS" Then
		АлгоритмХеширования = HashFunction.MD5;
	ElsIf Алгоритм = "SHA" Then
		АлгоритмХеширования = HashFunction.SHA1;
	ElsIf Алгоритм = "SHA-256" Then
		АлгоритмХеширования = HashFunction.SHA256;
	Else
		АлгоритмХеширования = Undefined;
	EndIf;

	Return АлгоритмХеширования;

EndFunction

Function ХешированиеДанных(Val Алгоритм, Val Данные)

	If TypeOf(Данные) = Type("String") Then
		Данные = GetBinaryDataFromString(Данные, TextEncoding.UTF8, False);
	EndIf;

	Хеширование = New DataHashing(Алгоритм);
	Хеширование.Append(Данные);

	Return Lower(GetHexStringFromBinaryData(Хеширование.HashSum));

EndFunction

Procedure Приостановить(ДлительностьОстановкиВСекундах)

	// Когда-нибудь в платформе сделают паузу и это можно будет выкинуть

	If ДлительностьОстановкиВСекундах < 1 Then
		Return;
	EndIf;

	ТекущаяДата = CurrentUniversalDate();
	ЖдатьДо = ТекущаяДата + ДлительностьОстановкиВСекундах;

	// BSLLS:UsingHardcodeNetworkAddress-off
	ЛокальныйХост = "127.0.0.0";
	КакойНибудьСвободныйПорт = 56476;
	// BSLLS:UsingHardcodeNetworkAddress-on
	While ТекущаяДата < ЖдатьДо Do
		Таймаут = ЖдатьДо - ТекущаяДата;
		Начало = CurrentUniversalDateInMilliseconds();
		Try
			Соединение = New HTTPConnection(
				ЛокальныйХост, КакойНибудьСвободныйПорт, Undefined, Undefined, Undefined, Таймаут);
			Соединение.Get(New HTTPRequest("/does_not_matter"));
		Except
			РеальныйТаймаут = CurrentUniversalDateInMilliseconds() - Начало;
		EndTry;
		МинимальныйТаймаутВМиллисекундах = 1000;
		If РеальныйТаймаут < МинимальныйТаймаутВМиллисекундах Then
			Raise(NStr("ru = 'Процедура Приостановить не работает должным образом';
									|en = 'Процедура Приостановить не работает должным образом';"));
		EndIf;
		ТекущаяДата = CurrentUniversalDate();
	EndDo;

EndProcedure

Function РассчитатьДлительностьПриостановки(Повтор, КоэффициентЭкспоненциальнойЗадержки, ЗаголовокRetryAfter, Остаток)

	If ЗаголовокRetryAfter <> False Then
		Длительность = ЧислоИзСтроки(ЗаголовокRetryAfter);

		If Длительность = 0 Then
			Date = ДатаИзСтрокиRFC7231(ЗаголовокRetryAfter);
			If ValueIsFilled(Date) Then
				Длительность = Date - CurrentUniversalDate();
			EndIf;
		EndIf;
	Else
		Длительность = КоэффициентЭкспоненциальнойЗадержки * Pow(2, Повтор - 1);
	EndIf;

	Длительность = Min(Длительность, Остаток);

	If Длительность < 0 Then
		Длительность = 0;
	EndIf;

	Return Длительность;

EndFunction

#EndRegion

#Region УниверсальныеСтруктурыДанных

Function ВыбратьЗначение(ОсновноеЗначение, ДополнительныеЗначения, Ключ, ЗначениеПоУмолчанию)

	If ОсновноеЗначение <> Undefined Then
		Return ОсновноеЗначение;
	EndIf;

	Значение = ЗначениеПоКлючу(ДополнительныеЗначения, Ключ);
	If Значение <> Undefined Then
		Return Значение;
	EndIf;

	Return ЗначениеПоУмолчанию;

EndFunction

Function ЗначениеПоКлючу(Структура, Ключ, ЗначениеПоУмолчанию = Undefined)

	If TypeOf(Структура) = Type("Structure") And Структура.Property(Ключ) Then
		Значение = Структура[Ключ];
	ElsIf TypeOf(Структура) = Type("Map") And Структура.Get(Ключ) <> Undefined Then
		Значение = Структура.Get(Ключ);
	Else
		Значение = ЗначениеПоУмолчанию;
	EndIf;

	Return Значение;

EndFunction

#EndRegion

#Region РаботаСоСтроками

Function ЧислоИзСтроки(Val Строка) Export

	ОписаниеТипа = New TypeDescription("Number");
	Return ОписаниеТипа.AdjustValue(Строка);

EndFunction

Function ДатаИзСтроки(Val Строка) Export

	КвалификаторДаты = New DateQualifiers(DateFractions.DateTime);
	ОписаниеТипа = New TypeDescription("Date", Undefined, Undefined, КвалификаторДаты);
	Return ОписаниеТипа.AdjustValue(Строка);

EndFunction

Function ДатаИзСтрокиRFC7231(Val Строка) Export

	Разделители = ",-:/\.";
	For Индекс = 1 To StrLen(Разделители) Do
		Разделитель = Mid(Разделители, Индекс, 1);
		Строка = StrReplace(Строка, Разделитель, " ");
	EndDo;
	Строка = StrReplace(Строка, "  ", " ");
	СоставляющиеДаты = StrSplit(Строка, " ");
	МесяцСтр = СоставляющиеДаты[2];

	Месяцы = StrSplit("Jan,Feb,Mar,Apr,May,Jun,Jul,Aug,Sep,Oct,Nov,Dec", ",");
	Месяц = Месяцы.Find(МесяцСтр);
	If Месяц = Undefined Then
		Return '00010101';
	EndIf;

	Дата = СоставляющиеДаты[3] + Format(Месяц + 1, "ND=2; NLZ=;") + СоставляющиеДаты[1];
	Время = СоставляющиеДаты[4] + СоставляющиеДаты[5] + СоставляющиеДаты[6];

	Return ДатаИзСтроки(Дата + Время);

EndFunction

Procedure РазбитьСтрокуПоРазделителю(ИзвлекаемаяЧасть, ОстальнаяЧасть, Разделитель, Инверсия = False)

	Индекс = StrFind(ОстальнаяЧасть, Разделитель);
	If Индекс Then
		ИзвлекаемаяЧасть = Left(ОстальнаяЧасть, Индекс - 1);
		ОстальнаяЧасть = Mid(ОстальнаяЧасть, Индекс + StrLen(Разделитель));
		If Инверсия Then
			ДляОбмена = ИзвлекаемаяЧасть;
			ИзвлекаемаяЧасть = ОстальнаяЧасть;
			ОстальнаяЧасть = ДляОбмена;
		EndIf;
	EndIf;

EndProcedure

Function РазделитьПоПервомуНайденномуРазделителю(Строка, Разделители)

	МинимальныйИндекс = StrLen(Строка);
	ПервыйРазделитель = "";

	For Each Разделитель In Разделители Do
		Индекс = StrFind(Строка, Разделитель);
		If Индекс = 0 Then
			Continue;
		EndIf;
		If Индекс < МинимальныйИндекс Then
			МинимальныйИндекс = Индекс;
			ПервыйРазделитель = Разделитель;
		EndIf;
	EndDo;

	Результат = New Array;
	If ValueIsFilled(ПервыйРазделитель) Then
		Результат.Add(Left(Строка, МинимальныйИндекс - 1));
		Результат.Add(Mid(Строка, МинимальныйИндекс + StrLen(ПервыйРазделитель)));
		Результат.Add(ПервыйРазделитель);
	Else
		Результат.Add(Строка);
		Результат.Add("");
		Результат.Add(Undefined);
	EndIf;

	Return Результат;

EndFunction

Function РазбитьСтрокуПоСтроке(Val Строка, Разделитель)

	Результат = New Array;
	While True Do
		Позиция = StrFind(Строка, Разделитель);
		If Позиция = 0 And ValueIsFilled(Строка) Then
			Результат.Add(Строка);
			Break;
		EndIf;

		ПерваяЧасть = Left(Строка, Позиция - StrLen(Разделитель) + 1);
		Результат.Add(ПерваяЧасть);
		Строка = Mid(Строка, Позиция + StrLen(Разделитель));
	EndDo;

	Return Результат;

EndFunction

Function ДобавитьЛидирующуюТочку(Val Домен)

	If Not StrStartsWith(Домен, ".") Then
		Домен = "." + Домен;
	EndIf;

	Return Домен;

EndFunction

Function ВырезатьТекст(Текст, МаксимальнаяДлинаТекста = 1000)
	
	If FindDisallowedXMLCharacters(Текст) Then
		Return NStr("ru = '<Данные>';
					|en = '<Данные>';");
	EndIf;
	
	If StrLen(Текст) <= МаксимальнаяДлинаТекста Then
		Результат = Текст;
	Else
		ПоловинаМаксимальнойДлиныТекста = МаксимальнаяДлинаТекста / 2;
		Результат = Left(Текст, ПоловинаМаксимальнойДлиныТекста);
		Результат = Результат + Chars.LF + "..." + Chars.LF;
		Результат = Результат + Right(Текст, ПоловинаМаксимальнойДлиныТекста);
	EndIf;
	
	Return Результат;
	
EndFunction

Function Объединить(ГлавныйИсточник, ДополнительныйИсточник)

	Результат = ГлавныйИсточник;
	Дополнить(ГлавныйИсточник, ДополнительныйИсточник);
	Return Результат;

EndFunction

Function Скопировать(Источник)
	
	Return ValueFromStringInternal(ValueToStringInternal(Источник));

EndFunction

Procedure Дополнить(Приемник, Источник)
	
	If Источник = Undefined Then
		Return;
	EndIf;
	
	For Each ЭлементИсточника In Источник Do
		ПараметрНайден = False;
		
		If TypeOf(Приемник) = Type("Map") Then
			ПараметрНайден = Приемник.Get(ЭлементИсточника) <> Undefined;
		EndIf;
		
		If TypeOf(Приемник) = Type("Structure") Then
			ПараметрНайден = Приемник.Property(ЭлементИсточника);
		EndIf;
		
		If Not ПараметрНайден Then
			Приемник.Insert(ЭлементИсточника.Key, ЭлементИсточника.Value);
		EndIf;
	EndDo;
		
EndProcedure

#EndRegion

#EndRegion
